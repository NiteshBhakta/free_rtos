
free.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000022  00800100  00001d10  00001da4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001d10  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000086  00800122  00800122  00001dc6  2**0
                  ALLOC
  3 .stab         000007bc  00000000  00000000  00001dc8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000017f  00000000  00000000  00002584  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00002703  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000480  00000000  00000000  00002732  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00005a9f  00000000  00000000  00002bb2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001287  00000000  00000000  00008651  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001d8c  00000000  00000000  000098d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000dac  00000000  00000000  0000b664  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001920  00000000  00000000  0000c410  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00005af0  00000000  00000000  0000dd30  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000560  00000000  00000000  00013820  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__vector_6>
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

		if( xWaitConditionMet != pdFALSE )
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
		{
			portYIELD_WITHIN_API();
      7a:	e0 e1       	ldi	r30, 0x10	; 16
      7c:	fd e1       	ldi	r31, 0x1D	; 29

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
      84:	a2 32       	cpi	r26, 0x22	; 34
      86:	b1 07       	cpc	r27, r17
		{
			taskENTER_CRITICAL();
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	21 e0       	ldi	r18, 0x01	; 1
      8c:	a2 e2       	ldi	r26, 0x22	; 34
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
      94:	a8 3a       	cpi	r26, 0xA8	; 168
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 53 00 	call	0xa6	; 0xa6 <main>
      9e:	0c 94 86 0e 	jmp	0x1d0c	; 0x1d0c <_exit>

000000a2 <__bad_interrupt>:
				{
					if( xClearOnExit != pdFALSE )
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <main>:
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
      a6:	84 b1       	in	r24, 0x04	; 4
      a8:	8f ef       	ldi	r24, 0xFF	; 255
      aa:	84 b9       	out	0x04, r24	; 4
      ac:	97 b1       	in	r25, 0x07	; 7
      ae:	87 b9       	out	0x07, r24	; 7
      b0:	e1 2c       	mov	r14, r1
      b2:	f1 2c       	mov	r15, r1
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
      b4:	00 e0       	ldi	r16, 0x00	; 0
      b6:	20 e0       	ldi	r18, 0x00	; 0
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
      b8:	30 e0       	ldi	r19, 0x00	; 0
      ba:	44 e6       	ldi	r20, 0x64	; 100
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
      bc:	50 e0       	ldi	r21, 0x00	; 0
      be:	66 e0       	ldi	r22, 0x06	; 6
      c0:	71 e0       	ldi	r23, 0x01	; 1
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
      c2:	82 e7       	ldi	r24, 0x72	; 114
      c4:	90 e0       	ldi	r25, 0x00	; 0
      c6:	0e 94 5a 06 	call	0xcb4	; 0xcb4 <xTaskCreate>
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
      ca:	20 e0       	ldi	r18, 0x00	; 0
      cc:	30 e0       	ldi	r19, 0x00	; 0
      ce:	44 e6       	ldi	r20, 0x64	; 100
      d0:	50 e0       	ldi	r21, 0x00	; 0
      d2:	6d e0       	ldi	r22, 0x0D	; 13
      d4:	71 e0       	ldi	r23, 0x01	; 1
      d6:	8e e8       	ldi	r24, 0x8E	; 142
      d8:	90 e0       	ldi	r25, 0x00	; 0
      da:	0e 94 5a 06 	call	0xcb4	; 0xcb4 <xTaskCreate>
      de:	0e 94 7a 07 	call	0xef4	; 0xef4 <vTaskStartScheduler>
	 while(1)
	{
		xTaskCreate(vta1 , "Task_1" , 100 , NULL , 0 , NULL );
		xTaskCreate(vta , "Task_2" , 100 ,NULL , 0 , NULL);
		//vTaskStartSchedular();
		vTaskStartScheduler();
      e2:	ff cf       	rjmp	.-2      	; 0xe2 <main+0x3c>

000000e4 <vta1>:

#include <avr/io.h>
#include "Free.h"
#include <util/delay.h>
void vta1( void *pnit )
{
      e4:	80 e0       	ldi	r24, 0x00	; 0
      e6:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t ucx = 0;
	for ( ucx = 0; ucx <= 128; ucx++)
	{
		PORTC |= ( 1 << ucx);
      e8:	41 e0       	ldi	r20, 0x01	; 1
      ea:	50 e0       	ldi	r21, 0x00	; 0
      ec:	68 b1       	in	r22, 0x08	; 8
      ee:	9a 01       	movw	r18, r20
      f0:	08 2e       	mov	r0, r24
      f2:	02 c0       	rjmp	.+4      	; 0xf8 <vta1+0x14>
      f4:	22 0f       	add	r18, r18
      f6:	33 1f       	adc	r19, r19
      f8:	0a 94       	dec	r0
      fa:	e2 f7       	brpl	.-8      	; 0xf4 <vta1+0x10>
      fc:	26 2b       	or	r18, r22
      fe:	28 b9       	out	0x08, r18	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     100:	2f e3       	ldi	r18, 0x3F	; 63
     102:	3d e0       	ldi	r19, 0x0D	; 13
     104:	63 e0       	ldi	r22, 0x03	; 3
     106:	21 50       	subi	r18, 0x01	; 1
     108:	30 40       	sbci	r19, 0x00	; 0
     10a:	60 40       	sbci	r22, 0x00	; 0
     10c:	e1 f7       	brne	.-8      	; 0x106 <vta1+0x22>
     10e:	00 c0       	rjmp	.+0      	; 0x110 <vta1+0x2c>
     110:	00 00       	nop
     112:	01 96       	adiw	r24, 0x01	; 1
#include "Free.h"
#include <util/delay.h>
void vta1( void *pnit )
{
	uint8_t ucx = 0;
	for ( ucx = 0; ucx <= 128; ucx++)
     114:	81 38       	cpi	r24, 0x81	; 129
     116:	91 05       	cpc	r25, r1
     118:	49 f7       	brne	.-46     	; 0xec <vta1+0x8>
		PORTC |= ( 1 << ucx);
		//ATaskDeley(1000);
		_delay_ms(1000);
		
	}
}
     11a:	08 95       	ret

0000011c <vta>:

void vta ( void *pnit1 )
{
     11c:	80 e0       	ldi	r24, 0x00	; 0
     11e:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t ucy=0;
	for ( ucy = 0; ucy <=7; ucy++)
	{
		PORTB |= ( 1 << ucy);
     120:	41 e0       	ldi	r20, 0x01	; 1
     122:	50 e0       	ldi	r21, 0x00	; 0
     124:	65 b1       	in	r22, 0x05	; 5
     126:	9a 01       	movw	r18, r20
     128:	08 2e       	mov	r0, r24
     12a:	02 c0       	rjmp	.+4      	; 0x130 <vta+0x14>
     12c:	22 0f       	add	r18, r18
     12e:	33 1f       	adc	r19, r19
     130:	0a 94       	dec	r0
     132:	e2 f7       	brpl	.-8      	; 0x12c <vta+0x10>
     134:	26 2b       	or	r18, r22
     136:	25 b9       	out	0x05, r18	; 5
     138:	2f e3       	ldi	r18, 0x3F	; 63
     13a:	3d e0       	ldi	r19, 0x0D	; 13
     13c:	63 e0       	ldi	r22, 0x03	; 3
     13e:	21 50       	subi	r18, 0x01	; 1
     140:	30 40       	sbci	r19, 0x00	; 0
     142:	60 40       	sbci	r22, 0x00	; 0
     144:	e1 f7       	brne	.-8      	; 0x13e <vta+0x22>
     146:	00 c0       	rjmp	.+0      	; 0x148 <vta+0x2c>
     148:	00 00       	nop
     14a:	01 96       	adiw	r24, 0x01	; 1
}

void vta ( void *pnit1 )
{
	uint8_t ucy=0;
	for ( ucy = 0; ucy <=7; ucy++)
     14c:	88 30       	cpi	r24, 0x08	; 8
     14e:	91 05       	cpc	r25, r1
     150:	49 f7       	brne	.-46     	; 0x124 <vta+0x8>
	{
		PORTB |= ( 1 << ucy);
		_delay_ms(1000);
	}
	
}
     152:	08 95       	ret

00000154 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     154:	cf 93       	push	r28
     156:	df 93       	push	r29
     158:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     15a:	0e 94 a8 07 	call	0xf50	; 0xf50 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     15e:	ce 01       	movw	r24, r28
     160:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <malloc>
     164:	d8 2f       	mov	r29, r24
     166:	c9 2f       	mov	r28, r25
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     168:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     16c:	8d 2f       	mov	r24, r29
     16e:	9c 2f       	mov	r25, r28
     170:	df 91       	pop	r29
     172:	cf 91       	pop	r28
     174:	08 95       	ret

00000176 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     176:	cf 93       	push	r28
     178:	df 93       	push	r29
     17a:	ec 01       	movw	r28, r24
	if( pv )
     17c:	00 97       	sbiw	r24, 0x00	; 0
     17e:	39 f0       	breq	.+14     	; 0x18e <vPortFree+0x18>
	{
		vTaskSuspendAll();
     180:	0e 94 a8 07 	call	0xf50	; 0xf50 <vTaskSuspendAll>
		{
			free( pv );
     184:	ce 01       	movw	r24, r28
     186:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     18a:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>
	}
}
     18e:	df 91       	pop	r29
     190:	cf 91       	pop	r28
     192:	08 95       	ret

00000194 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     194:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     196:	03 96       	adiw	r24, 0x03	; 3
     198:	92 83       	std	Z+2, r25	; 0x02
     19a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     19c:	2f ef       	ldi	r18, 0xFF	; 255
     19e:	3f ef       	ldi	r19, 0xFF	; 255
     1a0:	34 83       	std	Z+4, r19	; 0x04
     1a2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1a4:	96 83       	std	Z+6, r25	; 0x06
     1a6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1a8:	90 87       	std	Z+8, r25	; 0x08
     1aa:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     1ac:	10 82       	st	Z, r1
     1ae:	08 95       	ret

000001b0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     1b0:	fc 01       	movw	r30, r24
     1b2:	11 86       	std	Z+9, r1	; 0x09
     1b4:	10 86       	std	Z+8, r1	; 0x08
     1b6:	08 95       	ret

000001b8 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	9c 01       	movw	r18, r24
     1be:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     1c0:	dc 01       	movw	r26, r24
     1c2:	11 96       	adiw	r26, 0x01	; 1
     1c4:	cd 91       	ld	r28, X+
     1c6:	dc 91       	ld	r29, X
     1c8:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     1ca:	d3 83       	std	Z+3, r29	; 0x03
     1cc:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     1ce:	8c 81       	ldd	r24, Y+4	; 0x04
     1d0:	9d 81       	ldd	r25, Y+5	; 0x05
     1d2:	95 83       	std	Z+5, r25	; 0x05
     1d4:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     1d6:	8c 81       	ldd	r24, Y+4	; 0x04
     1d8:	9d 81       	ldd	r25, Y+5	; 0x05
     1da:	dc 01       	movw	r26, r24
     1dc:	13 96       	adiw	r26, 0x03	; 3
     1de:	7c 93       	st	X, r23
     1e0:	6e 93       	st	-X, r22
     1e2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     1e4:	7d 83       	std	Y+5, r23	; 0x05
     1e6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1e8:	31 87       	std	Z+9, r19	; 0x09
     1ea:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     1ec:	f9 01       	movw	r30, r18
     1ee:	80 81       	ld	r24, Z
     1f0:	8f 5f       	subi	r24, 0xFF	; 255
     1f2:	80 83       	st	Z, r24
}
     1f4:	df 91       	pop	r29
     1f6:	cf 91       	pop	r28
     1f8:	08 95       	ret

000001fa <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1fa:	cf 93       	push	r28
     1fc:	df 93       	push	r29
     1fe:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     200:	48 81       	ld	r20, Y
     202:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     204:	4f 3f       	cpi	r20, 0xFF	; 255
     206:	2f ef       	ldi	r18, 0xFF	; 255
     208:	52 07       	cpc	r21, r18
     20a:	21 f4       	brne	.+8      	; 0x214 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     20c:	fc 01       	movw	r30, r24
     20e:	a7 81       	ldd	r26, Z+7	; 0x07
     210:	b0 85       	ldd	r27, Z+8	; 0x08
     212:	0d c0       	rjmp	.+26     	; 0x22e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     214:	dc 01       	movw	r26, r24
     216:	13 96       	adiw	r26, 0x03	; 3
     218:	01 c0       	rjmp	.+2      	; 0x21c <vListInsert+0x22>
     21a:	df 01       	movw	r26, r30
     21c:	12 96       	adiw	r26, 0x02	; 2
     21e:	ed 91       	ld	r30, X+
     220:	fc 91       	ld	r31, X
     222:	13 97       	sbiw	r26, 0x03	; 3
     224:	20 81       	ld	r18, Z
     226:	31 81       	ldd	r19, Z+1	; 0x01
     228:	42 17       	cp	r20, r18
     22a:	53 07       	cpc	r21, r19
     22c:	b0 f7       	brcc	.-20     	; 0x21a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     22e:	12 96       	adiw	r26, 0x02	; 2
     230:	ed 91       	ld	r30, X+
     232:	fc 91       	ld	r31, X
     234:	13 97       	sbiw	r26, 0x03	; 3
     236:	fb 83       	std	Y+3, r31	; 0x03
     238:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     23a:	d5 83       	std	Z+5, r29	; 0x05
     23c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     23e:	bd 83       	std	Y+5, r27	; 0x05
     240:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     242:	13 96       	adiw	r26, 0x03	; 3
     244:	dc 93       	st	X, r29
     246:	ce 93       	st	-X, r28
     248:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     24a:	99 87       	std	Y+9, r25	; 0x09
     24c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     24e:	fc 01       	movw	r30, r24
     250:	20 81       	ld	r18, Z
     252:	2f 5f       	subi	r18, 0xFF	; 255
     254:	20 83       	st	Z, r18
}
     256:	df 91       	pop	r29
     258:	cf 91       	pop	r28
     25a:	08 95       	ret

0000025c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     25c:	cf 93       	push	r28
     25e:	df 93       	push	r29
     260:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     262:	a0 85       	ldd	r26, Z+8	; 0x08
     264:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     266:	c2 81       	ldd	r28, Z+2	; 0x02
     268:	d3 81       	ldd	r29, Z+3	; 0x03
     26a:	84 81       	ldd	r24, Z+4	; 0x04
     26c:	95 81       	ldd	r25, Z+5	; 0x05
     26e:	9d 83       	std	Y+5, r25	; 0x05
     270:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     272:	c4 81       	ldd	r28, Z+4	; 0x04
     274:	d5 81       	ldd	r29, Z+5	; 0x05
     276:	82 81       	ldd	r24, Z+2	; 0x02
     278:	93 81       	ldd	r25, Z+3	; 0x03
     27a:	9b 83       	std	Y+3, r25	; 0x03
     27c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     27e:	11 96       	adiw	r26, 0x01	; 1
     280:	cd 91       	ld	r28, X+
     282:	dc 91       	ld	r29, X
     284:	12 97       	sbiw	r26, 0x02	; 2
     286:	ce 17       	cp	r28, r30
     288:	df 07       	cpc	r29, r31
     28a:	31 f4       	brne	.+12     	; 0x298 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     28c:	8c 81       	ldd	r24, Y+4	; 0x04
     28e:	9d 81       	ldd	r25, Y+5	; 0x05
     290:	12 96       	adiw	r26, 0x02	; 2
     292:	9c 93       	st	X, r25
     294:	8e 93       	st	-X, r24
     296:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     298:	11 86       	std	Z+9, r1	; 0x09
     29a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     29c:	8c 91       	ld	r24, X
     29e:	81 50       	subi	r24, 0x01	; 1
     2a0:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     2a2:	df 91       	pop	r29
     2a4:	cf 91       	pop	r28
     2a6:	08 95       	ret

000002a8 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     2a8:	31 e1       	ldi	r19, 0x11	; 17
     2aa:	fc 01       	movw	r30, r24
     2ac:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     2ae:	31 97       	sbiw	r30, 0x01	; 1
     2b0:	22 e2       	ldi	r18, 0x22	; 34
     2b2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     2b4:	fc 01       	movw	r30, r24
     2b6:	32 97       	sbiw	r30, 0x02	; 2
     2b8:	a3 e3       	ldi	r26, 0x33	; 51
     2ba:	a0 83       	st	Z, r26

	*pxTopOfStack = 0;
	pxTopOfStack--;
#else
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     2bc:	fc 01       	movw	r30, r24
     2be:	33 97       	sbiw	r30, 0x03	; 3
     2c0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     2c2:	fc 01       	movw	r30, r24
     2c4:	34 97       	sbiw	r30, 0x04	; 4
     2c6:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     2c8:	fc 01       	movw	r30, r24
     2ca:	35 97       	sbiw	r30, 0x05	; 5
     2cc:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     2ce:	fc 01       	movw	r30, r24
     2d0:	36 97       	sbiw	r30, 0x06	; 6
     2d2:	60 e8       	ldi	r22, 0x80	; 128
     2d4:	60 83       	st	Z, r22
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     2d6:	fc 01       	movw	r30, r24
     2d8:	37 97       	sbiw	r30, 0x07	; 7
     2da:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     2dc:	fc 01       	movw	r30, r24
     2de:	38 97       	sbiw	r30, 0x08	; 8
     2e0:	62 e0       	ldi	r22, 0x02	; 2
     2e2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     2e4:	fc 01       	movw	r30, r24
     2e6:	39 97       	sbiw	r30, 0x09	; 9
     2e8:	63 e0       	ldi	r22, 0x03	; 3
     2ea:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     2ec:	fc 01       	movw	r30, r24
     2ee:	3a 97       	sbiw	r30, 0x0a	; 10
     2f0:	64 e0       	ldi	r22, 0x04	; 4
     2f2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     2f4:	fc 01       	movw	r30, r24
     2f6:	3b 97       	sbiw	r30, 0x0b	; 11
     2f8:	65 e0       	ldi	r22, 0x05	; 5
     2fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     2fc:	fc 01       	movw	r30, r24
     2fe:	3c 97       	sbiw	r30, 0x0c	; 12
     300:	66 e0       	ldi	r22, 0x06	; 6
     302:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     304:	fc 01       	movw	r30, r24
     306:	3d 97       	sbiw	r30, 0x0d	; 13
     308:	67 e0       	ldi	r22, 0x07	; 7
     30a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     30c:	fc 01       	movw	r30, r24
     30e:	3e 97       	sbiw	r30, 0x0e	; 14
     310:	68 e0       	ldi	r22, 0x08	; 8
     312:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     314:	fc 01       	movw	r30, r24
     316:	3f 97       	sbiw	r30, 0x0f	; 15
     318:	69 e0       	ldi	r22, 0x09	; 9
     31a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     31c:	fc 01       	movw	r30, r24
     31e:	70 97       	sbiw	r30, 0x10	; 16
     320:	60 e1       	ldi	r22, 0x10	; 16
     322:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     324:	fc 01       	movw	r30, r24
     326:	71 97       	sbiw	r30, 0x11	; 17
     328:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     32a:	fc 01       	movw	r30, r24
     32c:	72 97       	sbiw	r30, 0x12	; 18
     32e:	32 e1       	ldi	r19, 0x12	; 18
     330:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     332:	fc 01       	movw	r30, r24
     334:	73 97       	sbiw	r30, 0x13	; 19
     336:	33 e1       	ldi	r19, 0x13	; 19
     338:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     33a:	fc 01       	movw	r30, r24
     33c:	74 97       	sbiw	r30, 0x14	; 20
     33e:	34 e1       	ldi	r19, 0x14	; 20
     340:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     342:	fc 01       	movw	r30, r24
     344:	75 97       	sbiw	r30, 0x15	; 21
     346:	35 e1       	ldi	r19, 0x15	; 21
     348:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     34a:	fc 01       	movw	r30, r24
     34c:	76 97       	sbiw	r30, 0x16	; 22
     34e:	36 e1       	ldi	r19, 0x16	; 22
     350:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     352:	fc 01       	movw	r30, r24
     354:	77 97       	sbiw	r30, 0x17	; 23
     356:	37 e1       	ldi	r19, 0x17	; 23
     358:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     35a:	fc 01       	movw	r30, r24
     35c:	78 97       	sbiw	r30, 0x18	; 24
     35e:	38 e1       	ldi	r19, 0x18	; 24
     360:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     362:	fc 01       	movw	r30, r24
     364:	79 97       	sbiw	r30, 0x19	; 25
     366:	39 e1       	ldi	r19, 0x19	; 25
     368:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     36a:	fc 01       	movw	r30, r24
     36c:	7a 97       	sbiw	r30, 0x1a	; 26
     36e:	30 e2       	ldi	r19, 0x20	; 32
     370:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     372:	fc 01       	movw	r30, r24
     374:	7b 97       	sbiw	r30, 0x1b	; 27
     376:	31 e2       	ldi	r19, 0x21	; 33
     378:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     37a:	fc 01       	movw	r30, r24
     37c:	7c 97       	sbiw	r30, 0x1c	; 28
     37e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     380:	fc 01       	movw	r30, r24
     382:	7d 97       	sbiw	r30, 0x1d	; 29
     384:	23 e2       	ldi	r18, 0x23	; 35
     386:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     388:	fc 01       	movw	r30, r24
     38a:	7e 97       	sbiw	r30, 0x1e	; 30
     38c:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     38e:	fc 01       	movw	r30, r24
     390:	7f 97       	sbiw	r30, 0x1f	; 31
     392:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     394:	fc 01       	movw	r30, r24
     396:	b0 97       	sbiw	r30, 0x20	; 32
     398:	26 e2       	ldi	r18, 0x26	; 38
     39a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     39c:	fc 01       	movw	r30, r24
     39e:	b1 97       	sbiw	r30, 0x21	; 33
     3a0:	27 e2       	ldi	r18, 0x27	; 39
     3a2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     3a4:	fc 01       	movw	r30, r24
     3a6:	b2 97       	sbiw	r30, 0x22	; 34
     3a8:	28 e2       	ldi	r18, 0x28	; 40
     3aa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     3ac:	fc 01       	movw	r30, r24
     3ae:	b3 97       	sbiw	r30, 0x23	; 35
     3b0:	29 e2       	ldi	r18, 0x29	; 41
     3b2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     3b4:	fc 01       	movw	r30, r24
     3b6:	b4 97       	sbiw	r30, 0x24	; 36
     3b8:	20 e3       	ldi	r18, 0x30	; 48
     3ba:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     3bc:	fc 01       	movw	r30, r24
     3be:	b5 97       	sbiw	r30, 0x25	; 37
     3c0:	21 e3       	ldi	r18, 0x31	; 49
     3c2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     3c4:	9c 01       	movw	r18, r24
     3c6:	26 52       	subi	r18, 0x26	; 38
     3c8:	31 09       	sbc	r19, r1
}
     3ca:	82 2f       	mov	r24, r18
     3cc:	93 2f       	mov	r25, r19
     3ce:	08 95       	ret

000003d0 <xPortStartScheduler>:

//initialize watchdog
void prvSetupTimerInterrupt( void )
{
	//reset watchdog
	wdt_reset();
     3d0:	a8 95       	wdr

	//set up WDT Interrupt (rather than the WDT Reset).
	wdt_interrupt_enable( portUSE_WDTO );
     3d2:	20 ec       	ldi	r18, 0xC0	; 192
     3d4:	88 e1       	ldi	r24, 0x18	; 24
     3d6:	90 e0       	ldi	r25, 0x00	; 0
     3d8:	0f b6       	in	r0, 0x3f	; 63
     3da:	f8 94       	cli
     3dc:	a8 95       	wdr
     3de:	80 93 60 00 	sts	0x0060, r24
     3e2:	0f be       	out	0x3f, r0	; 63
     3e4:	20 93 60 00 	sts	0x0060, r18

	/* Setup the relevant timer hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     3e8:	a0 91 32 01 	lds	r26, 0x0132
     3ec:	b0 91 33 01 	lds	r27, 0x0133
     3f0:	cd 91       	ld	r28, X+
     3f2:	cd bf       	out	0x3d, r28	; 61
     3f4:	dd 91       	ld	r29, X+
     3f6:	de bf       	out	0x3e, r29	; 62
     3f8:	ff 91       	pop	r31
     3fa:	ef 91       	pop	r30
     3fc:	df 91       	pop	r29
     3fe:	cf 91       	pop	r28
     400:	bf 91       	pop	r27
     402:	af 91       	pop	r26
     404:	9f 91       	pop	r25
     406:	8f 91       	pop	r24
     408:	7f 91       	pop	r23
     40a:	6f 91       	pop	r22
     40c:	5f 91       	pop	r21
     40e:	4f 91       	pop	r20
     410:	3f 91       	pop	r19
     412:	2f 91       	pop	r18
     414:	1f 91       	pop	r17
     416:	0f 91       	pop	r16
     418:	ff 90       	pop	r15
     41a:	ef 90       	pop	r14
     41c:	df 90       	pop	r13
     41e:	cf 90       	pop	r12
     420:	bf 90       	pop	r11
     422:	af 90       	pop	r10
     424:	9f 90       	pop	r9
     426:	8f 90       	pop	r8
     428:	7f 90       	pop	r7
     42a:	6f 90       	pop	r6
     42c:	5f 90       	pop	r5
     42e:	4f 90       	pop	r4
     430:	3f 90       	pop	r3
     432:	2f 90       	pop	r2
     434:	1f 90       	pop	r1
     436:	0f 90       	pop	r0
     438:	0f be       	out	0x3f, r0	; 63
     43a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	__asm__ __volatile__ ( "ret" );
     43c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     43e:	81 e0       	ldi	r24, 0x01	; 1
     440:	08 95       	ret

00000442 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     442:	0f 92       	push	r0
     444:	0f b6       	in	r0, 0x3f	; 63
     446:	f8 94       	cli
     448:	0f 92       	push	r0
     44a:	1f 92       	push	r1
     44c:	11 24       	eor	r1, r1
     44e:	2f 92       	push	r2
     450:	3f 92       	push	r3
     452:	4f 92       	push	r4
     454:	5f 92       	push	r5
     456:	6f 92       	push	r6
     458:	7f 92       	push	r7
     45a:	8f 92       	push	r8
     45c:	9f 92       	push	r9
     45e:	af 92       	push	r10
     460:	bf 92       	push	r11
     462:	cf 92       	push	r12
     464:	df 92       	push	r13
     466:	ef 92       	push	r14
     468:	ff 92       	push	r15
     46a:	0f 93       	push	r16
     46c:	1f 93       	push	r17
     46e:	2f 93       	push	r18
     470:	3f 93       	push	r19
     472:	4f 93       	push	r20
     474:	5f 93       	push	r21
     476:	6f 93       	push	r22
     478:	7f 93       	push	r23
     47a:	8f 93       	push	r24
     47c:	9f 93       	push	r25
     47e:	af 93       	push	r26
     480:	bf 93       	push	r27
     482:	cf 93       	push	r28
     484:	df 93       	push	r29
     486:	ef 93       	push	r30
     488:	ff 93       	push	r31
     48a:	a0 91 32 01 	lds	r26, 0x0132
     48e:	b0 91 33 01 	lds	r27, 0x0133
     492:	0d b6       	in	r0, 0x3d	; 61
     494:	0d 92       	st	X+, r0
     496:	0e b6       	in	r0, 0x3e	; 62
     498:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     49a:	0e 94 2e 09 	call	0x125c	; 0x125c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     49e:	a0 91 32 01 	lds	r26, 0x0132
     4a2:	b0 91 33 01 	lds	r27, 0x0133
     4a6:	cd 91       	ld	r28, X+
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	dd 91       	ld	r29, X+
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	ff 91       	pop	r31
     4b0:	ef 91       	pop	r30
     4b2:	df 91       	pop	r29
     4b4:	cf 91       	pop	r28
     4b6:	bf 91       	pop	r27
     4b8:	af 91       	pop	r26
     4ba:	9f 91       	pop	r25
     4bc:	8f 91       	pop	r24
     4be:	7f 91       	pop	r23
     4c0:	6f 91       	pop	r22
     4c2:	5f 91       	pop	r21
     4c4:	4f 91       	pop	r20
     4c6:	3f 91       	pop	r19
     4c8:	2f 91       	pop	r18
     4ca:	1f 91       	pop	r17
     4cc:	0f 91       	pop	r16
     4ce:	ff 90       	pop	r15
     4d0:	ef 90       	pop	r14
     4d2:	df 90       	pop	r13
     4d4:	cf 90       	pop	r12
     4d6:	bf 90       	pop	r11
     4d8:	af 90       	pop	r10
     4da:	9f 90       	pop	r9
     4dc:	8f 90       	pop	r8
     4de:	7f 90       	pop	r7
     4e0:	6f 90       	pop	r6
     4e2:	5f 90       	pop	r5
     4e4:	4f 90       	pop	r4
     4e6:	3f 90       	pop	r3
     4e8:	2f 90       	pop	r2
     4ea:	1f 90       	pop	r1
     4ec:	0f 90       	pop	r0
     4ee:	0f be       	out	0x3f, r0	; 63
     4f0:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     4f2:	08 95       	ret

000004f4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     4f4:	0f 92       	push	r0
     4f6:	0f b6       	in	r0, 0x3f	; 63
     4f8:	f8 94       	cli
     4fa:	0f 92       	push	r0
     4fc:	1f 92       	push	r1
     4fe:	11 24       	eor	r1, r1
     500:	2f 92       	push	r2
     502:	3f 92       	push	r3
     504:	4f 92       	push	r4
     506:	5f 92       	push	r5
     508:	6f 92       	push	r6
     50a:	7f 92       	push	r7
     50c:	8f 92       	push	r8
     50e:	9f 92       	push	r9
     510:	af 92       	push	r10
     512:	bf 92       	push	r11
     514:	cf 92       	push	r12
     516:	df 92       	push	r13
     518:	ef 92       	push	r14
     51a:	ff 92       	push	r15
     51c:	0f 93       	push	r16
     51e:	1f 93       	push	r17
     520:	2f 93       	push	r18
     522:	3f 93       	push	r19
     524:	4f 93       	push	r20
     526:	5f 93       	push	r21
     528:	6f 93       	push	r22
     52a:	7f 93       	push	r23
     52c:	8f 93       	push	r24
     52e:	9f 93       	push	r25
     530:	af 93       	push	r26
     532:	bf 93       	push	r27
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
     538:	ef 93       	push	r30
     53a:	ff 93       	push	r31
     53c:	a0 91 32 01 	lds	r26, 0x0132
     540:	b0 91 33 01 	lds	r27, 0x0133
     544:	0d b6       	in	r0, 0x3d	; 61
     546:	0d 92       	st	X+, r0
     548:	0e b6       	in	r0, 0x3e	; 62
     54a:	0d 92       	st	X+, r0
	
	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
     54c:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
     54e:	0e 94 ba 07 	call	0xf74	; 0xf74 <xTaskIncrementTick>
     552:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     554:	0e 94 2e 09 	call	0x125c	; 0x125c <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
     558:	a0 91 32 01 	lds	r26, 0x0132
     55c:	b0 91 33 01 	lds	r27, 0x0133
     560:	cd 91       	ld	r28, X+
     562:	cd bf       	out	0x3d, r28	; 61
     564:	dd 91       	ld	r29, X+
     566:	de bf       	out	0x3e, r29	; 62
     568:	ff 91       	pop	r31
     56a:	ef 91       	pop	r30
     56c:	df 91       	pop	r29
     56e:	cf 91       	pop	r28
     570:	bf 91       	pop	r27
     572:	af 91       	pop	r26
     574:	9f 91       	pop	r25
     576:	8f 91       	pop	r24
     578:	7f 91       	pop	r23
     57a:	6f 91       	pop	r22
     57c:	5f 91       	pop	r21
     57e:	4f 91       	pop	r20
     580:	3f 91       	pop	r19
     582:	2f 91       	pop	r18
     584:	1f 91       	pop	r17
     586:	0f 91       	pop	r16
     588:	ff 90       	pop	r15
     58a:	ef 90       	pop	r14
     58c:	df 90       	pop	r13
     58e:	cf 90       	pop	r12
     590:	bf 90       	pop	r11
     592:	af 90       	pop	r10
     594:	9f 90       	pop	r9
     596:	8f 90       	pop	r8
     598:	7f 90       	pop	r7
     59a:	6f 90       	pop	r6
     59c:	5f 90       	pop	r5
     59e:	4f 90       	pop	r4
     5a0:	3f 90       	pop	r3
     5a2:	2f 90       	pop	r2
     5a4:	1f 90       	pop	r1
     5a6:	0f 90       	pop	r0
     5a8:	0f be       	out	0x3f, r0	; 63
     5aa:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     5ac:	08 95       	ret

000005ae <__vector_6>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
     5ae:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     5b2:	18 95       	reti

000005b4 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     5b4:	0f b6       	in	r0, 0x3f	; 63
     5b6:	f8 94       	cli
     5b8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     5ba:	fc 01       	movw	r30, r24
     5bc:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     5be:	0f 90       	pop	r0
     5c0:	0f be       	out	0x3f, r0	; 63
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     5c2:	81 e0       	ldi	r24, 0x01	; 1
     5c4:	91 11       	cpse	r25, r1
     5c6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
     5c8:	08 95       	ret

000005ca <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     5ca:	ff 92       	push	r15
     5cc:	0f 93       	push	r16
     5ce:	1f 93       	push	r17
     5d0:	cf 93       	push	r28
     5d2:	df 93       	push	r29
     5d4:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     5d6:	0f b6       	in	r0, 0x3f	; 63
     5d8:	f8 94       	cli
     5da:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     5dc:	fe 8c       	ldd	r15, Y+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     5de:	1f 14       	cp	r1, r15
     5e0:	9c f4       	brge	.+38     	; 0x608 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     5e2:	89 89       	ldd	r24, Y+17	; 0x11
     5e4:	81 11       	cpse	r24, r1
     5e6:	05 c0       	rjmp	.+10     	; 0x5f2 <prvUnlockQueue+0x28>
     5e8:	0f c0       	rjmp	.+30     	; 0x608 <prvUnlockQueue+0x3e>
     5ea:	89 89       	ldd	r24, Y+17	; 0x11
     5ec:	81 11       	cpse	r24, r1
     5ee:	04 c0       	rjmp	.+8      	; 0x5f8 <prvUnlockQueue+0x2e>
     5f0:	0b c0       	rjmp	.+22     	; 0x608 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     5f2:	8e 01       	movw	r16, r28
     5f4:	0f 5e       	subi	r16, 0xEF	; 239
     5f6:	1f 4f       	sbci	r17, 0xFF	; 255
     5f8:	c8 01       	movw	r24, r16
     5fa:	0e 94 b2 09 	call	0x1364	; 0x1364 <xTaskRemoveFromEventList>
     5fe:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     600:	0e 94 3f 0a 	call	0x147e	; 0x147e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
     604:	fa 94       	dec	r15
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     606:	89 f7       	brne	.-30     	; 0x5ea <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     608:	8f ef       	ldi	r24, 0xFF	; 255
     60a:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     60c:	0f 90       	pop	r0
     60e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     610:	0f b6       	in	r0, 0x3f	; 63
     612:	f8 94       	cli
     614:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
     616:	fd 8c       	ldd	r15, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
     618:	1f 14       	cp	r1, r15
     61a:	9c f4       	brge	.+38     	; 0x642 <prvUnlockQueue+0x78>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     61c:	88 85       	ldd	r24, Y+8	; 0x08
     61e:	81 11       	cpse	r24, r1
     620:	05 c0       	rjmp	.+10     	; 0x62c <prvUnlockQueue+0x62>
     622:	0f c0       	rjmp	.+30     	; 0x642 <prvUnlockQueue+0x78>
     624:	88 85       	ldd	r24, Y+8	; 0x08
     626:	81 11       	cpse	r24, r1
     628:	04 c0       	rjmp	.+8      	; 0x632 <prvUnlockQueue+0x68>
     62a:	0b c0       	rjmp	.+22     	; 0x642 <prvUnlockQueue+0x78>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     62c:	8e 01       	movw	r16, r28
     62e:	08 5f       	subi	r16, 0xF8	; 248
     630:	1f 4f       	sbci	r17, 0xFF	; 255
     632:	c8 01       	movw	r24, r16
     634:	0e 94 b2 09 	call	0x1364	; 0x1364 <xTaskRemoveFromEventList>
     638:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     63a:	0e 94 3f 0a 	call	0x147e	; 0x147e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
     63e:	fa 94       	dec	r15
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     640:	89 f7       	brne	.-30     	; 0x624 <prvUnlockQueue+0x5a>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     642:	8f ef       	ldi	r24, 0xFF	; 255
     644:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     646:	0f 90       	pop	r0
     648:	0f be       	out	0x3f, r0	; 63
}
     64a:	df 91       	pop	r29
     64c:	cf 91       	pop	r28
     64e:	1f 91       	pop	r17
     650:	0f 91       	pop	r16
     652:	ff 90       	pop	r15
     654:	08 95       	ret

00000656 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     656:	fc 01       	movw	r30, r24
     658:	86 2f       	mov	r24, r22
     65a:	97 2f       	mov	r25, r23
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     65c:	44 8d       	ldd	r20, Z+28	; 0x1c
     65e:	44 23       	and	r20, r20
     660:	a1 f0       	breq	.+40     	; 0x68a <prvCopyDataFromQueue+0x34>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     662:	26 81       	ldd	r18, Z+6	; 0x06
     664:	37 81       	ldd	r19, Z+7	; 0x07
     666:	24 0f       	add	r18, r20
     668:	31 1d       	adc	r19, r1
     66a:	37 83       	std	Z+7, r19	; 0x07
     66c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     66e:	a2 81       	ldd	r26, Z+2	; 0x02
     670:	b3 81       	ldd	r27, Z+3	; 0x03
     672:	2a 17       	cp	r18, r26
     674:	3b 07       	cpc	r19, r27
     676:	20 f0       	brcs	.+8      	; 0x680 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     678:	20 81       	ld	r18, Z
     67a:	31 81       	ldd	r19, Z+1	; 0x01
     67c:	37 83       	std	Z+7, r19	; 0x07
     67e:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     680:	66 81       	ldd	r22, Z+6	; 0x06
     682:	77 81       	ldd	r23, Z+7	; 0x07
     684:	50 e0       	ldi	r21, 0x00	; 0
     686:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <memcpy>
     68a:	08 95       	ret

0000068c <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     68c:	0f 93       	push	r16
     68e:	1f 93       	push	r17
     690:	cf 93       	push	r28
     692:	df 93       	push	r29
     694:	ec 01       	movw	r28, r24
     696:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     698:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     69a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     69c:	41 11       	cpse	r20, r1
     69e:	0c c0       	rjmp	.+24     	; 0x6b8 <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     6a0:	88 81       	ld	r24, Y
     6a2:	99 81       	ldd	r25, Y+1	; 0x01
     6a4:	89 2b       	or	r24, r25
     6a6:	09 f0       	breq	.+2      	; 0x6aa <prvCopyDataToQueue+0x1e>
     6a8:	42 c0       	rjmp	.+132    	; 0x72e <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     6aa:	8a 81       	ldd	r24, Y+2	; 0x02
     6ac:	9b 81       	ldd	r25, Y+3	; 0x03
     6ae:	0e 94 af 0a 	call	0x155e	; 0x155e <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     6b2:	1b 82       	std	Y+3, r1	; 0x03
     6b4:	1a 82       	std	Y+2, r1	; 0x02
     6b6:	42 c0       	rjmp	.+132    	; 0x73c <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     6b8:	01 11       	cpse	r16, r1
     6ba:	17 c0       	rjmp	.+46     	; 0x6ea <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     6bc:	50 e0       	ldi	r21, 0x00	; 0
     6be:	8c 81       	ldd	r24, Y+4	; 0x04
     6c0:	9d 81       	ldd	r25, Y+5	; 0x05
     6c2:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     6c6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6c8:	8c 81       	ldd	r24, Y+4	; 0x04
     6ca:	9d 81       	ldd	r25, Y+5	; 0x05
     6cc:	82 0f       	add	r24, r18
     6ce:	91 1d       	adc	r25, r1
     6d0:	9d 83       	std	Y+5, r25	; 0x05
     6d2:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     6d4:	2a 81       	ldd	r18, Y+2	; 0x02
     6d6:	3b 81       	ldd	r19, Y+3	; 0x03
     6d8:	82 17       	cp	r24, r18
     6da:	93 07       	cpc	r25, r19
     6dc:	50 f1       	brcs	.+84     	; 0x732 <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     6de:	88 81       	ld	r24, Y
     6e0:	99 81       	ldd	r25, Y+1	; 0x01
     6e2:	9d 83       	std	Y+5, r25	; 0x05
     6e4:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     6e6:	80 e0       	ldi	r24, 0x00	; 0
     6e8:	29 c0       	rjmp	.+82     	; 0x73c <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     6ea:	50 e0       	ldi	r21, 0x00	; 0
     6ec:	8e 81       	ldd	r24, Y+6	; 0x06
     6ee:	9f 81       	ldd	r25, Y+7	; 0x07
     6f0:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     6f4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6f6:	30 e0       	ldi	r19, 0x00	; 0
     6f8:	31 95       	neg	r19
     6fa:	21 95       	neg	r18
     6fc:	31 09       	sbc	r19, r1
     6fe:	8e 81       	ldd	r24, Y+6	; 0x06
     700:	9f 81       	ldd	r25, Y+7	; 0x07
     702:	82 0f       	add	r24, r18
     704:	93 1f       	adc	r25, r19
     706:	9f 83       	std	Y+7, r25	; 0x07
     708:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     70a:	68 81       	ld	r22, Y
     70c:	79 81       	ldd	r23, Y+1	; 0x01
     70e:	86 17       	cp	r24, r22
     710:	97 07       	cpc	r25, r23
     712:	30 f4       	brcc	.+12     	; 0x720 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     714:	8a 81       	ldd	r24, Y+2	; 0x02
     716:	9b 81       	ldd	r25, Y+3	; 0x03
     718:	28 0f       	add	r18, r24
     71a:	39 1f       	adc	r19, r25
     71c:	3f 83       	std	Y+7, r19	; 0x07
     71e:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     720:	02 30       	cpi	r16, 0x02	; 2
     722:	49 f4       	brne	.+18     	; 0x736 <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     724:	11 23       	and	r17, r17
     726:	49 f0       	breq	.+18     	; 0x73a <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     728:	11 50       	subi	r17, 0x01	; 1
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     72a:	80 e0       	ldi	r24, 0x00	; 0
     72c:	07 c0       	rjmp	.+14     	; 0x73c <prvCopyDataToQueue+0xb0>
     72e:	80 e0       	ldi	r24, 0x00	; 0
     730:	05 c0       	rjmp	.+10     	; 0x73c <prvCopyDataToQueue+0xb0>
     732:	80 e0       	ldi	r24, 0x00	; 0
     734:	03 c0       	rjmp	.+6      	; 0x73c <prvCopyDataToQueue+0xb0>
     736:	80 e0       	ldi	r24, 0x00	; 0
     738:	01 c0       	rjmp	.+2      	; 0x73c <prvCopyDataToQueue+0xb0>
     73a:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     73c:	1f 5f       	subi	r17, 0xFF	; 255
     73e:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
     740:	df 91       	pop	r29
     742:	cf 91       	pop	r28
     744:	1f 91       	pop	r17
     746:	0f 91       	pop	r16
     748:	08 95       	ret

0000074a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     750:	0f b6       	in	r0, 0x3f	; 63
     752:	f8 94       	cli
     754:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     756:	88 81       	ld	r24, Y
     758:	99 81       	ldd	r25, Y+1	; 0x01
     75a:	4b 8d       	ldd	r20, Y+27	; 0x1b
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     760:	30 e0       	ldi	r19, 0x00	; 0
     762:	42 9f       	mul	r20, r18
     764:	f0 01       	movw	r30, r0
     766:	43 9f       	mul	r20, r19
     768:	f0 0d       	add	r31, r0
     76a:	52 9f       	mul	r21, r18
     76c:	f0 0d       	add	r31, r0
     76e:	11 24       	eor	r1, r1
     770:	e8 0f       	add	r30, r24
     772:	f9 1f       	adc	r31, r25
     774:	fb 83       	std	Y+3, r31	; 0x03
     776:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     778:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     77a:	9d 83       	std	Y+5, r25	; 0x05
     77c:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     77e:	41 50       	subi	r20, 0x01	; 1
     780:	51 09       	sbc	r21, r1
     782:	24 9f       	mul	r18, r20
     784:	f0 01       	movw	r30, r0
     786:	25 9f       	mul	r18, r21
     788:	f0 0d       	add	r31, r0
     78a:	34 9f       	mul	r19, r20
     78c:	f0 0d       	add	r31, r0
     78e:	11 24       	eor	r1, r1
     790:	8e 0f       	add	r24, r30
     792:	9f 1f       	adc	r25, r31
     794:	9f 83       	std	Y+7, r25	; 0x07
     796:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     798:	8f ef       	ldi	r24, 0xFF	; 255
     79a:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     79c:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     79e:	61 11       	cpse	r22, r1
     7a0:	0c c0       	rjmp	.+24     	; 0x7ba <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     7a2:	88 85       	ldd	r24, Y+8	; 0x08
     7a4:	88 23       	and	r24, r24
     7a6:	89 f0       	breq	.+34     	; 0x7ca <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     7a8:	ce 01       	movw	r24, r28
     7aa:	08 96       	adiw	r24, 0x08	; 8
     7ac:	0e 94 b2 09 	call	0x1364	; 0x1364 <xTaskRemoveFromEventList>
     7b0:	88 23       	and	r24, r24
     7b2:	59 f0       	breq	.+22     	; 0x7ca <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
     7b4:	0e 94 21 02 	call	0x442	; 0x442 <vPortYield>
     7b8:	08 c0       	rjmp	.+16     	; 0x7ca <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     7ba:	ce 01       	movw	r24, r28
     7bc:	08 96       	adiw	r24, 0x08	; 8
     7be:	0e 94 ca 00 	call	0x194	; 0x194 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     7c2:	ce 01       	movw	r24, r28
     7c4:	41 96       	adiw	r24, 0x11	; 17
     7c6:	0e 94 ca 00 	call	0x194	; 0x194 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     7ca:	0f 90       	pop	r0
     7cc:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     7ce:	81 e0       	ldi	r24, 0x01	; 1
     7d0:	df 91       	pop	r29
     7d2:	cf 91       	pop	r28
     7d4:	08 95       	ret

000007d6 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
     7d6:	0f 93       	push	r16
     7d8:	1f 93       	push	r17
     7da:	cf 93       	push	r28
     7dc:	df 93       	push	r29
     7de:	08 2f       	mov	r16, r24
     7e0:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
     7e2:	66 23       	and	r22, r22
     7e4:	d9 f0       	breq	.+54     	; 0x81c <xQueueGenericCreate+0x46>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     7e6:	86 9f       	mul	r24, r22
     7e8:	c0 01       	movw	r24, r0
     7ea:	11 24       	eor	r1, r1
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     7ec:	4f 96       	adiw	r24, 0x1f	; 31
     7ee:	0e 94 aa 00 	call	0x154	; 0x154 <pvPortMalloc>
     7f2:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     7f4:	00 97       	sbiw	r24, 0x00	; 0
     7f6:	21 f4       	brne	.+8      	; 0x800 <xQueueGenericCreate+0x2a>
     7f8:	0e c0       	rjmp	.+28     	; 0x816 <xQueueGenericCreate+0x40>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     7fa:	d9 83       	std	Y+1, r29	; 0x01
     7fc:	c8 83       	st	Y, r28
     7fe:	05 c0       	rjmp	.+10     	; 0x80a <xQueueGenericCreate+0x34>

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
     800:	9c 01       	movw	r18, r24
     802:	21 5e       	subi	r18, 0xE1	; 225
     804:	3f 4f       	sbci	r19, 0xFF	; 255
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     806:	39 83       	std	Y+1, r19	; 0x01
     808:	28 83       	st	Y, r18
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
     80a:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
     80c:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     80e:	61 e0       	ldi	r22, 0x01	; 1
     810:	ce 01       	movw	r24, r28
     812:	0e 94 a5 03 	call	0x74a	; 0x74a <xQueueGenericReset>
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
     816:	8c 2f       	mov	r24, r28
     818:	9d 2f       	mov	r25, r29
     81a:	08 c0       	rjmp	.+16     	; 0x82c <xQueueGenericCreate+0x56>
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     81c:	8f e1       	ldi	r24, 0x1F	; 31
     81e:	90 e0       	ldi	r25, 0x00	; 0
     820:	0e 94 aa 00 	call	0x154	; 0x154 <pvPortMalloc>
     824:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     826:	00 97       	sbiw	r24, 0x00	; 0
     828:	41 f7       	brne	.-48     	; 0x7fa <xQueueGenericCreate+0x24>
     82a:	f5 cf       	rjmp	.-22     	; 0x816 <xQueueGenericCreate+0x40>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
     82c:	df 91       	pop	r29
     82e:	cf 91       	pop	r28
     830:	1f 91       	pop	r17
     832:	0f 91       	pop	r16
     834:	08 95       	ret

00000836 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     836:	9f 92       	push	r9
     838:	af 92       	push	r10
     83a:	bf 92       	push	r11
     83c:	cf 92       	push	r12
     83e:	df 92       	push	r13
     840:	ef 92       	push	r14
     842:	ff 92       	push	r15
     844:	0f 93       	push	r16
     846:	1f 93       	push	r17
     848:	cf 93       	push	r28
     84a:	df 93       	push	r29
     84c:	00 d0       	rcall	.+0      	; 0x84e <xQueueGenericSend+0x18>
     84e:	00 d0       	rcall	.+0      	; 0x850 <xQueueGenericSend+0x1a>
     850:	1f 92       	push	r1
     852:	cd b7       	in	r28, 0x3d	; 61
     854:	de b7       	in	r29, 0x3e	; 62
     856:	8c 01       	movw	r16, r24
     858:	6b 01       	movw	r12, r22
     85a:	5d 83       	std	Y+5, r21	; 0x05
     85c:	4c 83       	std	Y+4, r20	; 0x04
     85e:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     860:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     862:	99 24       	eor	r9, r9
     864:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     866:	7c 01       	movw	r14, r24
     868:	88 e0       	ldi	r24, 0x08	; 8
     86a:	e8 0e       	add	r14, r24
     86c:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     86e:	0f b6       	in	r0, 0x3f	; 63
     870:	f8 94       	cli
     872:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     874:	f8 01       	movw	r30, r16
     876:	92 8d       	ldd	r25, Z+26	; 0x1a
     878:	83 8d       	ldd	r24, Z+27	; 0x1b
     87a:	98 17       	cp	r25, r24
     87c:	18 f0       	brcs	.+6      	; 0x884 <xQueueGenericSend+0x4e>
     87e:	f2 e0       	ldi	r31, 0x02	; 2
     880:	af 12       	cpse	r10, r31
     882:	19 c0       	rjmp	.+50     	; 0x8b6 <xQueueGenericSend+0x80>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     884:	4a 2d       	mov	r20, r10
     886:	b6 01       	movw	r22, r12
     888:	c8 01       	movw	r24, r16
     88a:	0e 94 46 03 	call	0x68c	; 0x68c <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     88e:	f8 01       	movw	r30, r16
     890:	91 89       	ldd	r25, Z+17	; 0x11
     892:	99 23       	and	r25, r25
     894:	49 f0       	breq	.+18     	; 0x8a8 <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     896:	c8 01       	movw	r24, r16
     898:	41 96       	adiw	r24, 0x11	; 17
     89a:	0e 94 b2 09 	call	0x1364	; 0x1364 <xTaskRemoveFromEventList>
     89e:	88 23       	and	r24, r24
     8a0:	31 f0       	breq	.+12     	; 0x8ae <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     8a2:	0e 94 21 02 	call	0x442	; 0x442 <vPortYield>
     8a6:	03 c0       	rjmp	.+6      	; 0x8ae <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     8a8:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     8aa:	0e 94 21 02 	call	0x442	; 0x442 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     8ae:	0f 90       	pop	r0
     8b0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     8b2:	81 e0       	ldi	r24, 0x01	; 1
     8b4:	50 c0       	rjmp	.+160    	; 0x956 <__stack+0x57>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     8b6:	ec 81       	ldd	r30, Y+4	; 0x04
     8b8:	fd 81       	ldd	r31, Y+5	; 0x05
     8ba:	ef 2b       	or	r30, r31
     8bc:	21 f4       	brne	.+8      	; 0x8c6 <xQueueGenericSend+0x90>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     8be:	0f 90       	pop	r0
     8c0:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     8c2:	80 e0       	ldi	r24, 0x00	; 0
     8c4:	48 c0       	rjmp	.+144    	; 0x956 <__stack+0x57>
				}
				else if( xEntryTimeSet == pdFALSE )
     8c6:	b1 10       	cpse	r11, r1
     8c8:	05 c0       	rjmp	.+10     	; 0x8d4 <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     8ca:	ce 01       	movw	r24, r28
     8cc:	01 96       	adiw	r24, 0x01	; 1
     8ce:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     8d2:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     8d4:	0f 90       	pop	r0
     8d6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     8d8:	0e 94 a8 07 	call	0xf50	; 0xf50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     8dc:	0f b6       	in	r0, 0x3f	; 63
     8de:	f8 94       	cli
     8e0:	0f 92       	push	r0
     8e2:	f8 01       	movw	r30, r16
     8e4:	85 8d       	ldd	r24, Z+29	; 0x1d
     8e6:	8f 3f       	cpi	r24, 0xFF	; 255
     8e8:	09 f4       	brne	.+2      	; 0x8ec <xQueueGenericSend+0xb6>
     8ea:	15 8e       	std	Z+29, r1	; 0x1d
     8ec:	f8 01       	movw	r30, r16
     8ee:	86 8d       	ldd	r24, Z+30	; 0x1e
     8f0:	8f 3f       	cpi	r24, 0xFF	; 255
     8f2:	09 f4       	brne	.+2      	; 0x8f6 <xQueueGenericSend+0xc0>
     8f4:	16 8e       	std	Z+30, r1	; 0x1e
     8f6:	0f 90       	pop	r0
     8f8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     8fa:	be 01       	movw	r22, r28
     8fc:	6c 5f       	subi	r22, 0xFC	; 252
     8fe:	7f 4f       	sbci	r23, 0xFF	; 255
     900:	ce 01       	movw	r24, r28
     902:	01 96       	adiw	r24, 0x01	; 1
     904:	0e 94 06 0a 	call	0x140c	; 0x140c <xTaskCheckForTimeOut>
     908:	81 11       	cpse	r24, r1
     90a:	1f c0       	rjmp	.+62     	; 0x94a <__stack+0x4b>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     912:	f8 01       	movw	r30, r16
     914:	92 8d       	ldd	r25, Z+26	; 0x1a
     916:	83 8d       	ldd	r24, Z+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     918:	0f 90       	pop	r0
     91a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     91c:	98 13       	cpse	r25, r24
     91e:	0f c0       	rjmp	.+30     	; 0x93e <__stack+0x3f>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     920:	6c 81       	ldd	r22, Y+4	; 0x04
     922:	7d 81       	ldd	r23, Y+5	; 0x05
     924:	c7 01       	movw	r24, r14
     926:	0e 94 86 09 	call	0x130c	; 0x130c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     92a:	c8 01       	movw	r24, r16
     92c:	0e 94 e5 02 	call	0x5ca	; 0x5ca <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     930:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>
     934:	81 11       	cpse	r24, r1
     936:	9b cf       	rjmp	.-202    	; 0x86e <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
     938:	0e 94 21 02 	call	0x442	; 0x442 <vPortYield>
     93c:	98 cf       	rjmp	.-208    	; 0x86e <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     93e:	c8 01       	movw	r24, r16
     940:	0e 94 e5 02 	call	0x5ca	; 0x5ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
     944:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>
     948:	92 cf       	rjmp	.-220    	; 0x86e <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     94a:	c8 01       	movw	r24, r16
     94c:	0e 94 e5 02 	call	0x5ca	; 0x5ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
     950:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     954:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     956:	0f 90       	pop	r0
     958:	0f 90       	pop	r0
     95a:	0f 90       	pop	r0
     95c:	0f 90       	pop	r0
     95e:	0f 90       	pop	r0
     960:	df 91       	pop	r29
     962:	cf 91       	pop	r28
     964:	1f 91       	pop	r17
     966:	0f 91       	pop	r16
     968:	ff 90       	pop	r15
     96a:	ef 90       	pop	r14
     96c:	df 90       	pop	r13
     96e:	cf 90       	pop	r12
     970:	bf 90       	pop	r11
     972:	af 90       	pop	r10
     974:	9f 90       	pop	r9
     976:	08 95       	ret

00000978 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
     978:	ff 92       	push	r15
     97a:	0f 93       	push	r16
     97c:	1f 93       	push	r17
     97e:	cf 93       	push	r28
     980:	df 93       	push	r29
     982:	ec 01       	movw	r28, r24
     984:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     986:	9a 8d       	ldd	r25, Y+26	; 0x1a
     988:	8b 8d       	ldd	r24, Y+27	; 0x1b
     98a:	98 17       	cp	r25, r24
     98c:	10 f0       	brcs	.+4      	; 0x992 <xQueueGenericSendFromISR+0x1a>
     98e:	22 30       	cpi	r18, 0x02	; 2
     990:	e1 f4       	brne	.+56     	; 0x9ca <xQueueGenericSendFromISR+0x52>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
     992:	fe 8c       	ldd	r15, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     994:	42 2f       	mov	r20, r18
     996:	ce 01       	movw	r24, r28
     998:	0e 94 46 03 	call	0x68c	; 0x68c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
     99c:	8f ef       	ldi	r24, 0xFF	; 255
     99e:	f8 12       	cpse	r15, r24
     9a0:	10 c0       	rjmp	.+32     	; 0x9c2 <xQueueGenericSendFromISR+0x4a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     9a2:	89 89       	ldd	r24, Y+17	; 0x11
     9a4:	88 23       	and	r24, r24
     9a6:	99 f0       	breq	.+38     	; 0x9ce <xQueueGenericSendFromISR+0x56>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     9a8:	ce 01       	movw	r24, r28
     9aa:	41 96       	adiw	r24, 0x11	; 17
     9ac:	0e 94 b2 09 	call	0x1364	; 0x1364 <xTaskRemoveFromEventList>
     9b0:	88 23       	and	r24, r24
     9b2:	79 f0       	breq	.+30     	; 0x9d2 <xQueueGenericSendFromISR+0x5a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     9b4:	01 15       	cp	r16, r1
     9b6:	11 05       	cpc	r17, r1
     9b8:	71 f0       	breq	.+28     	; 0x9d6 <xQueueGenericSendFromISR+0x5e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     9ba:	81 e0       	ldi	r24, 0x01	; 1
     9bc:	f8 01       	movw	r30, r16
     9be:	80 83       	st	Z, r24
     9c0:	0b c0       	rjmp	.+22     	; 0x9d8 <xQueueGenericSendFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     9c2:	f3 94       	inc	r15
     9c4:	fe 8e       	std	Y+30, r15	; 0x1e
			}

			xReturn = pdPASS;
     9c6:	81 e0       	ldi	r24, 0x01	; 1
     9c8:	07 c0       	rjmp	.+14     	; 0x9d8 <xQueueGenericSendFromISR+0x60>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     9ca:	80 e0       	ldi	r24, 0x00	; 0
     9cc:	05 c0       	rjmp	.+10     	; 0x9d8 <xQueueGenericSendFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
     9ce:	81 e0       	ldi	r24, 0x01	; 1
     9d0:	03 c0       	rjmp	.+6      	; 0x9d8 <xQueueGenericSendFromISR+0x60>
     9d2:	81 e0       	ldi	r24, 0x01	; 1
     9d4:	01 c0       	rjmp	.+2      	; 0x9d8 <xQueueGenericSendFromISR+0x60>
     9d6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     9d8:	df 91       	pop	r29
     9da:	cf 91       	pop	r28
     9dc:	1f 91       	pop	r17
     9de:	0f 91       	pop	r16
     9e0:	ff 90       	pop	r15
     9e2:	08 95       	ret

000009e4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     9e4:	8f 92       	push	r8
     9e6:	9f 92       	push	r9
     9e8:	af 92       	push	r10
     9ea:	bf 92       	push	r11
     9ec:	cf 92       	push	r12
     9ee:	df 92       	push	r13
     9f0:	ef 92       	push	r14
     9f2:	ff 92       	push	r15
     9f4:	0f 93       	push	r16
     9f6:	1f 93       	push	r17
     9f8:	cf 93       	push	r28
     9fa:	df 93       	push	r29
     9fc:	00 d0       	rcall	.+0      	; 0x9fe <xQueueGenericReceive+0x1a>
     9fe:	00 d0       	rcall	.+0      	; 0xa00 <xQueueGenericReceive+0x1c>
     a00:	1f 92       	push	r1
     a02:	cd b7       	in	r28, 0x3d	; 61
     a04:	de b7       	in	r29, 0x3e	; 62
     a06:	8c 01       	movw	r16, r24
     a08:	6b 01       	movw	r12, r22
     a0a:	5d 83       	std	Y+5, r21	; 0x05
     a0c:	4c 83       	std	Y+4, r20	; 0x04
     a0e:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE;
     a10:	91 2c       	mov	r9, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     a12:	88 24       	eor	r8, r8
     a14:	83 94       	inc	r8
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a16:	7c 01       	movw	r14, r24
     a18:	81 e1       	ldi	r24, 0x11	; 17
     a1a:	e8 0e       	add	r14, r24
     a1c:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     a1e:	0f b6       	in	r0, 0x3f	; 63
     a20:	f8 94       	cli
     a22:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     a24:	f8 01       	movw	r30, r16
     a26:	b2 8c       	ldd	r11, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     a28:	bb 20       	and	r11, r11
     a2a:	91 f1       	breq	.+100    	; 0xa90 <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     a2c:	e6 80       	ldd	r14, Z+6	; 0x06
     a2e:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     a30:	b6 01       	movw	r22, r12
     a32:	c8 01       	movw	r24, r16
     a34:	0e 94 2b 03 	call	0x656	; 0x656 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     a38:	a1 10       	cpse	r10, r1
     a3a:	19 c0       	rjmp	.+50     	; 0xa6e <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     a3c:	ba 94       	dec	r11
     a3e:	f8 01       	movw	r30, r16
     a40:	b2 8e       	std	Z+26, r11	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     a42:	80 81       	ld	r24, Z
     a44:	91 81       	ldd	r25, Z+1	; 0x01
     a46:	89 2b       	or	r24, r25
     a48:	29 f4       	brne	.+10     	; 0xa54 <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     a4a:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <pvTaskIncrementMutexHeldCount>
     a4e:	f8 01       	movw	r30, r16
     a50:	93 83       	std	Z+3, r25	; 0x03
     a52:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     a54:	f8 01       	movw	r30, r16
     a56:	80 85       	ldd	r24, Z+8	; 0x08
     a58:	88 23       	and	r24, r24
     a5a:	b1 f0       	breq	.+44     	; 0xa88 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     a5c:	c8 01       	movw	r24, r16
     a5e:	08 96       	adiw	r24, 0x08	; 8
     a60:	0e 94 b2 09 	call	0x1364	; 0x1364 <xTaskRemoveFromEventList>
     a64:	88 23       	and	r24, r24
     a66:	81 f0       	breq	.+32     	; 0xa88 <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
     a68:	0e 94 21 02 	call	0x442	; 0x442 <vPortYield>
     a6c:	0d c0       	rjmp	.+26     	; 0xa88 <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     a6e:	f8 01       	movw	r30, r16
     a70:	f7 82       	std	Z+7, r15	; 0x07
     a72:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a74:	81 89       	ldd	r24, Z+17	; 0x11
     a76:	88 23       	and	r24, r24
     a78:	39 f0       	breq	.+14     	; 0xa88 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a7a:	c8 01       	movw	r24, r16
     a7c:	41 96       	adiw	r24, 0x11	; 17
     a7e:	0e 94 b2 09 	call	0x1364	; 0x1364 <xTaskRemoveFromEventList>
     a82:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     a84:	0e 94 21 02 	call	0x442	; 0x442 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     a88:	0f 90       	pop	r0
     a8a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     a8c:	81 e0       	ldi	r24, 0x01	; 1
     a8e:	5f c0       	rjmp	.+190    	; 0xb4e <xQueueGenericReceive+0x16a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     a90:	4c 81       	ldd	r20, Y+4	; 0x04
     a92:	5d 81       	ldd	r21, Y+5	; 0x05
     a94:	45 2b       	or	r20, r21
     a96:	21 f4       	brne	.+8      	; 0xaa0 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     a98:	0f 90       	pop	r0
     a9a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     a9c:	80 e0       	ldi	r24, 0x00	; 0
     a9e:	57 c0       	rjmp	.+174    	; 0xb4e <xQueueGenericReceive+0x16a>
				}
				else if( xEntryTimeSet == pdFALSE )
     aa0:	91 10       	cpse	r9, r1
     aa2:	05 c0       	rjmp	.+10     	; 0xaae <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     aa4:	ce 01       	movw	r24, r28
     aa6:	01 96       	adiw	r24, 0x01	; 1
     aa8:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     aac:	98 2c       	mov	r9, r8
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     aae:	0f 90       	pop	r0
     ab0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     ab2:	0e 94 a8 07 	call	0xf50	; 0xf50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     ab6:	0f b6       	in	r0, 0x3f	; 63
     ab8:	f8 94       	cli
     aba:	0f 92       	push	r0
     abc:	f8 01       	movw	r30, r16
     abe:	85 8d       	ldd	r24, Z+29	; 0x1d
     ac0:	8f 3f       	cpi	r24, 0xFF	; 255
     ac2:	09 f4       	brne	.+2      	; 0xac6 <xQueueGenericReceive+0xe2>
     ac4:	15 8e       	std	Z+29, r1	; 0x1d
     ac6:	f8 01       	movw	r30, r16
     ac8:	86 8d       	ldd	r24, Z+30	; 0x1e
     aca:	8f 3f       	cpi	r24, 0xFF	; 255
     acc:	09 f4       	brne	.+2      	; 0xad0 <xQueueGenericReceive+0xec>
     ace:	16 8e       	std	Z+30, r1	; 0x1e
     ad0:	0f 90       	pop	r0
     ad2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ad4:	be 01       	movw	r22, r28
     ad6:	6c 5f       	subi	r22, 0xFC	; 252
     ad8:	7f 4f       	sbci	r23, 0xFF	; 255
     ada:	ce 01       	movw	r24, r28
     adc:	01 96       	adiw	r24, 0x01	; 1
     ade:	0e 94 06 0a 	call	0x140c	; 0x140c <xTaskCheckForTimeOut>
     ae2:	81 11       	cpse	r24, r1
     ae4:	28 c0       	rjmp	.+80     	; 0xb36 <xQueueGenericReceive+0x152>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     ae6:	c8 01       	movw	r24, r16
     ae8:	0e 94 da 02 	call	0x5b4	; 0x5b4 <prvIsQueueEmpty>
     aec:	88 23       	and	r24, r24
     aee:	e9 f0       	breq	.+58     	; 0xb2a <xQueueGenericReceive+0x146>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     af0:	f8 01       	movw	r30, r16
     af2:	80 81       	ld	r24, Z
     af4:	91 81       	ldd	r25, Z+1	; 0x01
     af6:	89 2b       	or	r24, r25
     af8:	49 f4       	brne	.+18     	; 0xb0c <xQueueGenericReceive+0x128>
					{
						taskENTER_CRITICAL();
     afa:	0f b6       	in	r0, 0x3f	; 63
     afc:	f8 94       	cli
     afe:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     b00:	82 81       	ldd	r24, Z+2	; 0x02
     b02:	93 81       	ldd	r25, Z+3	; 0x03
     b04:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     b08:	0f 90       	pop	r0
     b0a:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b0c:	6c 81       	ldd	r22, Y+4	; 0x04
     b0e:	7d 81       	ldd	r23, Y+5	; 0x05
     b10:	c7 01       	movw	r24, r14
     b12:	0e 94 86 09 	call	0x130c	; 0x130c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     b16:	c8 01       	movw	r24, r16
     b18:	0e 94 e5 02 	call	0x5ca	; 0x5ca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     b1c:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>
     b20:	81 11       	cpse	r24, r1
     b22:	7d cf       	rjmp	.-262    	; 0xa1e <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
     b24:	0e 94 21 02 	call	0x442	; 0x442 <vPortYield>
     b28:	7a cf       	rjmp	.-268    	; 0xa1e <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b2a:	c8 01       	movw	r24, r16
     b2c:	0e 94 e5 02 	call	0x5ca	; 0x5ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b30:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>
     b34:	74 cf       	rjmp	.-280    	; 0xa1e <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     b36:	c8 01       	movw	r24, r16
     b38:	0e 94 e5 02 	call	0x5ca	; 0x5ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b3c:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b40:	c8 01       	movw	r24, r16
     b42:	0e 94 da 02 	call	0x5b4	; 0x5b4 <prvIsQueueEmpty>
     b46:	88 23       	and	r24, r24
     b48:	09 f4       	brne	.+2      	; 0xb4c <xQueueGenericReceive+0x168>
     b4a:	69 cf       	rjmp	.-302    	; 0xa1e <xQueueGenericReceive+0x3a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     b4c:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     b4e:	0f 90       	pop	r0
     b50:	0f 90       	pop	r0
     b52:	0f 90       	pop	r0
     b54:	0f 90       	pop	r0
     b56:	0f 90       	pop	r0
     b58:	df 91       	pop	r29
     b5a:	cf 91       	pop	r28
     b5c:	1f 91       	pop	r17
     b5e:	0f 91       	pop	r16
     b60:	ff 90       	pop	r15
     b62:	ef 90       	pop	r14
     b64:	df 90       	pop	r13
     b66:	cf 90       	pop	r12
     b68:	bf 90       	pop	r11
     b6a:	af 90       	pop	r10
     b6c:	9f 90       	pop	r9
     b6e:	8f 90       	pop	r8
     b70:	08 95       	ret

00000b72 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
     b72:	cf 93       	push	r28
     b74:	df 93       	push	r29
     b76:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
     b78:	0f b6       	in	r0, 0x3f	; 63
     b7a:	f8 94       	cli
     b7c:	0f 92       	push	r0
     b7e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b80:	8f 3f       	cpi	r24, 0xFF	; 255
     b82:	09 f4       	brne	.+2      	; 0xb86 <vQueueWaitForMessageRestricted+0x14>
     b84:	1d 8e       	std	Y+29, r1	; 0x1d
     b86:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b88:	8f 3f       	cpi	r24, 0xFF	; 255
     b8a:	09 f4       	brne	.+2      	; 0xb8e <vQueueWaitForMessageRestricted+0x1c>
     b8c:	1e 8e       	std	Y+30, r1	; 0x1e
     b8e:	0f 90       	pop	r0
     b90:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     b92:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b94:	81 11       	cpse	r24, r1
     b96:	04 c0       	rjmp	.+8      	; 0xba0 <vQueueWaitForMessageRestricted+0x2e>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
     b98:	ce 01       	movw	r24, r28
     b9a:	41 96       	adiw	r24, 0x11	; 17
     b9c:	0e 94 98 09 	call	0x1330	; 0x1330 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
     ba0:	ce 01       	movw	r24, r28
     ba2:	0e 94 e5 02 	call	0x5ca	; 0x5ca <prvUnlockQueue>
	}
     ba6:	df 91       	pop	r29
     ba8:	cf 91       	pop	r28
     baa:	08 95       	ret

00000bac <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     bac:	e0 91 30 01 	lds	r30, 0x0130
     bb0:	f0 91 31 01 	lds	r31, 0x0131
     bb4:	80 81       	ld	r24, Z
     bb6:	81 11       	cpse	r24, r1
     bb8:	07 c0       	rjmp	.+14     	; 0xbc8 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     bba:	8f ef       	ldi	r24, 0xFF	; 255
     bbc:	9f ef       	ldi	r25, 0xFF	; 255
     bbe:	90 93 24 01 	sts	0x0124, r25
     bc2:	80 93 23 01 	sts	0x0123, r24
     bc6:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     bc8:	e0 91 30 01 	lds	r30, 0x0130
     bcc:	f0 91 31 01 	lds	r31, 0x0131
     bd0:	05 80       	ldd	r0, Z+5	; 0x05
     bd2:	f6 81       	ldd	r31, Z+6	; 0x06
     bd4:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     bd6:	06 80       	ldd	r0, Z+6	; 0x06
     bd8:	f7 81       	ldd	r31, Z+7	; 0x07
     bda:	e0 2d       	mov	r30, r0
     bdc:	82 81       	ldd	r24, Z+2	; 0x02
     bde:	93 81       	ldd	r25, Z+3	; 0x03
     be0:	90 93 24 01 	sts	0x0124, r25
     be4:	80 93 23 01 	sts	0x0123, r24
     be8:	08 95       	ret

00000bea <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     bea:	ff 92       	push	r15
     bec:	0f 93       	push	r16
     bee:	1f 93       	push	r17
     bf0:	cf 93       	push	r28
     bf2:	df 93       	push	r29
     bf4:	ec 01       	movw	r28, r24
     bf6:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     bf8:	00 91 2a 01 	lds	r16, 0x012A
     bfc:	10 91 2b 01 	lds	r17, 0x012B
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     c00:	80 91 32 01 	lds	r24, 0x0132
     c04:	90 91 33 01 	lds	r25, 0x0133
     c08:	02 96       	adiw	r24, 0x02	; 2
     c0a:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     c0e:	cf 3f       	cpi	r28, 0xFF	; 255
     c10:	8f ef       	ldi	r24, 0xFF	; 255
     c12:	d8 07       	cpc	r29, r24
     c14:	69 f4       	brne	.+26     	; 0xc30 <prvAddCurrentTaskToDelayedList+0x46>
     c16:	ff 20       	and	r15, r15
     c18:	59 f0       	breq	.+22     	; 0xc30 <prvAddCurrentTaskToDelayedList+0x46>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     c1a:	60 91 32 01 	lds	r22, 0x0132
     c1e:	70 91 33 01 	lds	r23, 0x0133
     c22:	6e 5f       	subi	r22, 0xFE	; 254
     c24:	7f 4f       	sbci	r23, 0xFF	; 255
     c26:	8d e7       	ldi	r24, 0x7D	; 125
     c28:	91 e0       	ldi	r25, 0x01	; 1
     c2a:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <vListInsertEnd>
     c2e:	2f c0       	rjmp	.+94     	; 0xc8e <prvAddCurrentTaskToDelayedList+0xa4>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     c30:	c0 0f       	add	r28, r16
     c32:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     c34:	e0 91 32 01 	lds	r30, 0x0132
     c38:	f0 91 33 01 	lds	r31, 0x0133
     c3c:	d3 83       	std	Z+3, r29	; 0x03
     c3e:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
     c40:	c0 17       	cp	r28, r16
     c42:	d1 07       	cpc	r29, r17
     c44:	68 f4       	brcc	.+26     	; 0xc60 <prvAddCurrentTaskToDelayedList+0x76>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     c46:	60 91 32 01 	lds	r22, 0x0132
     c4a:	70 91 33 01 	lds	r23, 0x0133
     c4e:	80 91 2e 01 	lds	r24, 0x012E
     c52:	90 91 2f 01 	lds	r25, 0x012F
     c56:	6e 5f       	subi	r22, 0xFE	; 254
     c58:	7f 4f       	sbci	r23, 0xFF	; 255
     c5a:	0e 94 fd 00 	call	0x1fa	; 0x1fa <vListInsert>
     c5e:	17 c0       	rjmp	.+46     	; 0xc8e <prvAddCurrentTaskToDelayedList+0xa4>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     c60:	60 91 32 01 	lds	r22, 0x0132
     c64:	70 91 33 01 	lds	r23, 0x0133
     c68:	80 91 30 01 	lds	r24, 0x0130
     c6c:	90 91 31 01 	lds	r25, 0x0131
     c70:	6e 5f       	subi	r22, 0xFE	; 254
     c72:	7f 4f       	sbci	r23, 0xFF	; 255
     c74:	0e 94 fd 00 	call	0x1fa	; 0x1fa <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     c78:	80 91 23 01 	lds	r24, 0x0123
     c7c:	90 91 24 01 	lds	r25, 0x0124
     c80:	c8 17       	cp	r28, r24
     c82:	d9 07       	cpc	r29, r25
     c84:	20 f4       	brcc	.+8      	; 0xc8e <prvAddCurrentTaskToDelayedList+0xa4>
				{
					xNextTaskUnblockTime = xTimeToWake;
     c86:	d0 93 24 01 	sts	0x0124, r29
     c8a:	c0 93 23 01 	sts	0x0123, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     c8e:	df 91       	pop	r29
     c90:	cf 91       	pop	r28
     c92:	1f 91       	pop	r17
     c94:	0f 91       	pop	r16
     c96:	ff 90       	pop	r15
     c98:	08 95       	ret

00000c9a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
     c9a:	cf 93       	push	r28
     c9c:	df 93       	push	r29
     c9e:	ec 01       	movw	r28, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     ca0:	8f 89       	ldd	r24, Y+23	; 0x17
     ca2:	98 8d       	ldd	r25, Y+24	; 0x18
     ca4:	0e 94 bb 00 	call	0x176	; 0x176 <vPortFree>
			vPortFree( pxTCB );
     ca8:	ce 01       	movw	r24, r28
     caa:	0e 94 bb 00 	call	0x176	; 0x176 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
     cae:	df 91       	pop	r29
     cb0:	cf 91       	pop	r28
     cb2:	08 95       	ret

00000cb4 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
     cb4:	5f 92       	push	r5
     cb6:	6f 92       	push	r6
     cb8:	7f 92       	push	r7
     cba:	8f 92       	push	r8
     cbc:	9f 92       	push	r9
     cbe:	af 92       	push	r10
     cc0:	bf 92       	push	r11
     cc2:	cf 92       	push	r12
     cc4:	df 92       	push	r13
     cc6:	ef 92       	push	r14
     cc8:	ff 92       	push	r15
     cca:	0f 93       	push	r16
     ccc:	1f 93       	push	r17
     cce:	cf 93       	push	r28
     cd0:	df 93       	push	r29
     cd2:	4c 01       	movw	r8, r24
     cd4:	5b 01       	movw	r10, r22
     cd6:	6a 01       	movw	r12, r20
     cd8:	39 01       	movw	r6, r18
     cda:	50 2e       	mov	r5, r16
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     cdc:	ca 01       	movw	r24, r20
     cde:	0e 94 aa 00 	call	0x154	; 0x154 <pvPortMalloc>
     ce2:	8c 01       	movw	r16, r24

			if( pxStack != NULL )
     ce4:	00 97       	sbiw	r24, 0x00	; 0
     ce6:	09 f4       	brne	.+2      	; 0xcea <xTaskCreate+0x36>
     ce8:	f4 c0       	rjmp	.+488    	; 0xed2 <xTaskCreate+0x21e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
     cea:	88 e2       	ldi	r24, 0x28	; 40
     cec:	90 e0       	ldi	r25, 0x00	; 0
     cee:	0e 94 aa 00 	call	0x154	; 0x154 <pvPortMalloc>
     cf2:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     cf4:	00 97       	sbiw	r24, 0x00	; 0
     cf6:	b1 f0       	breq	.+44     	; 0xd24 <xTaskCreate+0x70>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     cf8:	18 8f       	std	Y+24, r17	; 0x18
     cfa:	0f 8b       	std	Y+23, r16	; 0x17

	/* Avoid dependency on memset() if it is not required. */
	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
     cfc:	a6 01       	movw	r20, r12
     cfe:	65 ea       	ldi	r22, 0xA5	; 165
     d00:	70 e0       	ldi	r23, 0x00	; 0
     d02:	c8 01       	movw	r24, r16
     d04:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
     d08:	81 e0       	ldi	r24, 0x01	; 1
     d0a:	c8 1a       	sub	r12, r24
     d0c:	d1 08       	sbc	r13, r1
     d0e:	8f 89       	ldd	r24, Y+23	; 0x17
     d10:	98 8d       	ldd	r25, Y+24	; 0x18
     d12:	c8 0e       	add	r12, r24
     d14:	d9 1e       	adc	r13, r25
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     d16:	d5 01       	movw	r26, r10
     d18:	8c 91       	ld	r24, X
     d1a:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     d1c:	8c 91       	ld	r24, X
     d1e:	81 11       	cpse	r24, r1
     d20:	05 c0       	rjmp	.+10     	; 0xd2c <xTaskCreate+0x78>
     d22:	16 c0       	rjmp	.+44     	; 0xd50 <xTaskCreate+0x9c>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     d24:	c8 01       	movw	r24, r16
     d26:	0e 94 bb 00 	call	0x176	; 0x176 <vPortFree>
     d2a:	d3 c0       	rjmp	.+422    	; 0xed2 <xTaskCreate+0x21e>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
     d2c:	ae 01       	movw	r20, r28
     d2e:	46 5e       	subi	r20, 0xE6	; 230
     d30:	5f 4f       	sbci	r21, 0xFF	; 255
     d32:	f5 01       	movw	r30, r10
     d34:	31 96       	adiw	r30, 0x01	; 1
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     d36:	21 e0       	ldi	r18, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
     d38:	cf 01       	movw	r24, r30
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     d3a:	31 91       	ld	r19, Z+
     d3c:	da 01       	movw	r26, r20
     d3e:	3d 93       	st	X+, r19
     d40:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     d42:	dc 01       	movw	r26, r24
     d44:	8c 91       	ld	r24, X
     d46:	88 23       	and	r24, r24
     d48:	19 f0       	breq	.+6      	; 0xd50 <xTaskCreate+0x9c>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     d4a:	2f 5f       	subi	r18, 0xFF	; 255
     d4c:	28 30       	cpi	r18, 0x08	; 8
     d4e:	a1 f7       	brne	.-24     	; 0xd38 <xTaskCreate+0x84>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     d50:	18 a2       	std	Y+32, r1	; 0x20
     d52:	b3 e0       	ldi	r27, 0x03	; 3
     d54:	b5 15       	cp	r27, r5
     d56:	20 f4       	brcc	.+8      	; 0xd60 <xTaskCreate+0xac>
     d58:	0f 2e       	mov	r0, r31
     d5a:	f3 e0       	ldi	r31, 0x03	; 3
     d5c:	5f 2e       	mov	r5, r31
     d5e:	f0 2d       	mov	r31, r0
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     d60:	5e 8a       	std	Y+22, r5	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
     d62:	59 a2       	std	Y+33, r5	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
     d64:	1a a2       	std	Y+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     d66:	8e 01       	movw	r16, r28
     d68:	0e 5f       	subi	r16, 0xFE	; 254
     d6a:	1f 4f       	sbci	r17, 0xFF	; 255
     d6c:	c8 01       	movw	r24, r16
     d6e:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     d72:	ce 01       	movw	r24, r28
     d74:	0c 96       	adiw	r24, 0x0c	; 12
     d76:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     d7a:	d9 87       	std	Y+9, r29	; 0x09
     d7c:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d7e:	84 e0       	ldi	r24, 0x04	; 4
     d80:	90 e0       	ldi	r25, 0x00	; 0
     d82:	85 19       	sub	r24, r5
     d84:	91 09       	sbc	r25, r1
     d86:	9d 87       	std	Y+13, r25	; 0x0d
     d88:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     d8a:	db 8b       	std	Y+19, r29	; 0x13
     d8c:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     d8e:	1b a2       	std	Y+35, r1	; 0x23
     d90:	1c a2       	std	Y+36, r1	; 0x24
     d92:	1d a2       	std	Y+37, r1	; 0x25
     d94:	1e a2       	std	Y+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     d96:	1f a2       	std	Y+39, r1	; 0x27
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     d98:	a3 01       	movw	r20, r6
     d9a:	b4 01       	movw	r22, r8
     d9c:	c6 01       	movw	r24, r12
     d9e:	0e 94 54 01 	call	0x2a8	; 0x2a8 <pxPortInitialiseStack>
     da2:	99 83       	std	Y+1, r25	; 0x01
     da4:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
     da6:	e1 14       	cp	r14, r1
     da8:	f1 04       	cpc	r15, r1
     daa:	19 f0       	breq	.+6      	; 0xdb2 <xTaskCreate+0xfe>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     dac:	f7 01       	movw	r30, r14
     dae:	d1 83       	std	Z+1, r29	; 0x01
     db0:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     db2:	0f b6       	in	r0, 0x3f	; 63
     db4:	f8 94       	cli
     db6:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     db8:	80 91 2c 01 	lds	r24, 0x012C
     dbc:	8f 5f       	subi	r24, 0xFF	; 255
     dbe:	80 93 2c 01 	sts	0x012C, r24
		if( pxCurrentTCB == NULL )
     dc2:	80 91 32 01 	lds	r24, 0x0132
     dc6:	90 91 33 01 	lds	r25, 0x0133
     dca:	89 2b       	or	r24, r25
     dcc:	09 f0       	breq	.+2      	; 0xdd0 <xTaskCreate+0x11c>
     dce:	40 c0       	rjmp	.+128    	; 0xe50 <xTaskCreate+0x19c>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     dd0:	d0 93 33 01 	sts	0x0133, r29
     dd4:	c0 93 32 01 	sts	0x0132, r28

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     dd8:	80 91 2c 01 	lds	r24, 0x012C
     ddc:	81 30       	cpi	r24, 0x01	; 1
     dde:	09 f0       	breq	.+2      	; 0xde2 <xTaskCreate+0x12e>
     de0:	47 c0       	rjmp	.+142    	; 0xe70 <xTaskCreate+0x1bc>
     de2:	e1 2c       	mov	r14, r1
     de4:	f1 2c       	mov	r15, r1
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     de6:	c7 01       	movw	r24, r14
     de8:	88 0f       	add	r24, r24
     dea:	99 1f       	adc	r25, r25
     dec:	88 0f       	add	r24, r24
     dee:	99 1f       	adc	r25, r25
     df0:	88 0f       	add	r24, r24
     df2:	99 1f       	adc	r25, r25
     df4:	8e 0d       	add	r24, r14
     df6:	9f 1d       	adc	r25, r15
     df8:	8b 5c       	subi	r24, 0xCB	; 203
     dfa:	9e 4f       	sbci	r25, 0xFE	; 254
     dfc:	0e 94 ca 00 	call	0x194	; 0x194 <vListInitialise>
     e00:	ff ef       	ldi	r31, 0xFF	; 255
     e02:	ef 1a       	sub	r14, r31
     e04:	ff 0a       	sbc	r15, r31

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     e06:	84 e0       	ldi	r24, 0x04	; 4
     e08:	e8 16       	cp	r14, r24
     e0a:	f1 04       	cpc	r15, r1
     e0c:	61 f7       	brne	.-40     	; 0xde6 <xTaskCreate+0x132>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
     e0e:	89 e5       	ldi	r24, 0x59	; 89
     e10:	91 e0       	ldi	r25, 0x01	; 1
     e12:	0e 94 ca 00 	call	0x194	; 0x194 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     e16:	82 e6       	ldi	r24, 0x62	; 98
     e18:	91 e0       	ldi	r25, 0x01	; 1
     e1a:	0e 94 ca 00 	call	0x194	; 0x194 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     e1e:	8b e6       	ldi	r24, 0x6B	; 107
     e20:	91 e0       	ldi	r25, 0x01	; 1
     e22:	0e 94 ca 00 	call	0x194	; 0x194 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     e26:	84 e7       	ldi	r24, 0x74	; 116
     e28:	91 e0       	ldi	r25, 0x01	; 1
     e2a:	0e 94 ca 00 	call	0x194	; 0x194 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     e2e:	8d e7       	ldi	r24, 0x7D	; 125
     e30:	91 e0       	ldi	r25, 0x01	; 1
     e32:	0e 94 ca 00 	call	0x194	; 0x194 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     e36:	89 e5       	ldi	r24, 0x59	; 89
     e38:	91 e0       	ldi	r25, 0x01	; 1
     e3a:	90 93 31 01 	sts	0x0131, r25
     e3e:	80 93 30 01 	sts	0x0130, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     e42:	82 e6       	ldi	r24, 0x62	; 98
     e44:	91 e0       	ldi	r25, 0x01	; 1
     e46:	90 93 2f 01 	sts	0x012F, r25
     e4a:	80 93 2e 01 	sts	0x012E, r24
     e4e:	10 c0       	rjmp	.+32     	; 0xe70 <xTaskCreate+0x1bc>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     e50:	80 91 28 01 	lds	r24, 0x0128
     e54:	81 11       	cpse	r24, r1
     e56:	0c c0       	rjmp	.+24     	; 0xe70 <xTaskCreate+0x1bc>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     e58:	e0 91 32 01 	lds	r30, 0x0132
     e5c:	f0 91 33 01 	lds	r31, 0x0133
     e60:	96 89       	ldd	r25, Z+22	; 0x16
     e62:	8e 89       	ldd	r24, Y+22	; 0x16
     e64:	89 17       	cp	r24, r25
     e66:	20 f0       	brcs	.+8      	; 0xe70 <xTaskCreate+0x1bc>
				{
					pxCurrentTCB = pxNewTCB;
     e68:	d0 93 33 01 	sts	0x0133, r29
     e6c:	c0 93 32 01 	sts	0x0132, r28
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     e70:	80 91 34 01 	lds	r24, 0x0134
     e74:	8f 5f       	subi	r24, 0xFF	; 255
     e76:	80 93 34 01 	sts	0x0134, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     e7a:	8e 89       	ldd	r24, Y+22	; 0x16
     e7c:	90 91 29 01 	lds	r25, 0x0129
     e80:	98 17       	cp	r25, r24
     e82:	10 f4       	brcc	.+4      	; 0xe88 <xTaskCreate+0x1d4>
     e84:	80 93 29 01 	sts	0x0129, r24
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	9c 01       	movw	r18, r24
     e8c:	22 0f       	add	r18, r18
     e8e:	33 1f       	adc	r19, r19
     e90:	22 0f       	add	r18, r18
     e92:	33 1f       	adc	r19, r19
     e94:	22 0f       	add	r18, r18
     e96:	33 1f       	adc	r19, r19
     e98:	82 0f       	add	r24, r18
     e9a:	93 1f       	adc	r25, r19
     e9c:	b8 01       	movw	r22, r16
     e9e:	8b 5c       	subi	r24, 0xCB	; 203
     ea0:	9e 4f       	sbci	r25, 0xFE	; 254
     ea2:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     ea6:	0f 90       	pop	r0
     ea8:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     eaa:	80 91 28 01 	lds	r24, 0x0128
     eae:	88 23       	and	r24, r24
     eb0:	61 f0       	breq	.+24     	; 0xeca <xTaskCreate+0x216>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     eb2:	e0 91 32 01 	lds	r30, 0x0132
     eb6:	f0 91 33 01 	lds	r31, 0x0133
     eba:	96 89       	ldd	r25, Z+22	; 0x16
     ebc:	8e 89       	ldd	r24, Y+22	; 0x16
     ebe:	98 17       	cp	r25, r24
     ec0:	30 f4       	brcc	.+12     	; 0xece <xTaskCreate+0x21a>
		{
			taskYIELD_IF_USING_PREEMPTION();
     ec2:	0e 94 21 02 	call	0x442	; 0x442 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     ec6:	81 e0       	ldi	r24, 0x01	; 1
     ec8:	05 c0       	rjmp	.+10     	; 0xed4 <xTaskCreate+0x220>
     eca:	81 e0       	ldi	r24, 0x01	; 1
     ecc:	03 c0       	rjmp	.+6      	; 0xed4 <xTaskCreate+0x220>
     ece:	81 e0       	ldi	r24, 0x01	; 1
     ed0:	01 c0       	rjmp	.+2      	; 0xed4 <xTaskCreate+0x220>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     ed2:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     ed4:	df 91       	pop	r29
     ed6:	cf 91       	pop	r28
     ed8:	1f 91       	pop	r17
     eda:	0f 91       	pop	r16
     edc:	ff 90       	pop	r15
     ede:	ef 90       	pop	r14
     ee0:	df 90       	pop	r13
     ee2:	cf 90       	pop	r12
     ee4:	bf 90       	pop	r11
     ee6:	af 90       	pop	r10
     ee8:	9f 90       	pop	r9
     eea:	8f 90       	pop	r8
     eec:	7f 90       	pop	r7
     eee:	6f 90       	pop	r6
     ef0:	5f 90       	pop	r5
     ef2:	08 95       	ret

00000ef4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     ef4:	ef 92       	push	r14
     ef6:	ff 92       	push	r15
     ef8:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     efa:	0f 2e       	mov	r0, r31
     efc:	f6 e8       	ldi	r31, 0x86	; 134
     efe:	ef 2e       	mov	r14, r31
     f00:	f1 e0       	ldi	r31, 0x01	; 1
     f02:	ff 2e       	mov	r15, r31
     f04:	f0 2d       	mov	r31, r0
     f06:	00 e0       	ldi	r16, 0x00	; 0
     f08:	20 e0       	ldi	r18, 0x00	; 0
     f0a:	30 e0       	ldi	r19, 0x00	; 0
     f0c:	40 ec       	ldi	r20, 0xC0	; 192
     f0e:	50 e0       	ldi	r21, 0x00	; 0
     f10:	64 e1       	ldi	r22, 0x14	; 20
     f12:	71 e0       	ldi	r23, 0x01	; 1
     f14:	85 ef       	ldi	r24, 0xF5	; 245
     f16:	98 e0       	ldi	r25, 0x08	; 8
     f18:	0e 94 5a 06 	call	0xcb4	; 0xcb4 <xTaskCreate>
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
     f1c:	81 30       	cpi	r24, 0x01	; 1
     f1e:	a1 f4       	brne	.+40     	; 0xf48 <vTaskStartScheduler+0x54>
		{
			xReturn = xTimerCreateTimerTask();
     f20:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <xTimerCreateTimerTask>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     f24:	81 30       	cpi	r24, 0x01	; 1
     f26:	81 f4       	brne	.+32     	; 0xf48 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     f28:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     f2a:	8f ef       	ldi	r24, 0xFF	; 255
     f2c:	9f ef       	ldi	r25, 0xFF	; 255
     f2e:	90 93 24 01 	sts	0x0124, r25
     f32:	80 93 23 01 	sts	0x0123, r24
		xSchedulerRunning = pdTRUE;
     f36:	81 e0       	ldi	r24, 0x01	; 1
     f38:	80 93 28 01 	sts	0x0128, r24
		xTickCount = ( TickType_t ) 0U;
     f3c:	10 92 2b 01 	sts	0x012B, r1
     f40:	10 92 2a 01 	sts	0x012A, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     f44:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     f48:	0f 91       	pop	r16
     f4a:	ff 90       	pop	r15
     f4c:	ef 90       	pop	r14
     f4e:	08 95       	ret

00000f50 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     f50:	80 91 22 01 	lds	r24, 0x0122
     f54:	8f 5f       	subi	r24, 0xFF	; 255
     f56:	80 93 22 01 	sts	0x0122, r24
     f5a:	08 95       	ret

00000f5c <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	f8 94       	cli
     f60:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     f62:	20 91 2a 01 	lds	r18, 0x012A
     f66:	30 91 2b 01 	lds	r19, 0x012B
	}
	portTICK_TYPE_EXIT_CRITICAL();
     f6a:	0f 90       	pop	r0
     f6c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     f6e:	82 2f       	mov	r24, r18
     f70:	93 2f       	mov	r25, r19
     f72:	08 95       	ret

00000f74 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     f74:	cf 92       	push	r12
     f76:	df 92       	push	r13
     f78:	ef 92       	push	r14
     f7a:	ff 92       	push	r15
     f7c:	0f 93       	push	r16
     f7e:	1f 93       	push	r17
     f80:	cf 93       	push	r28
     f82:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     f84:	80 91 22 01 	lds	r24, 0x0122
     f88:	81 11       	cpse	r24, r1
     f8a:	98 c0       	rjmp	.+304    	; 0x10bc <xTaskIncrementTick+0x148>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     f8c:	e0 90 2a 01 	lds	r14, 0x012A
     f90:	f0 90 2b 01 	lds	r15, 0x012B
     f94:	8f ef       	ldi	r24, 0xFF	; 255
     f96:	e8 1a       	sub	r14, r24
     f98:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     f9a:	f0 92 2b 01 	sts	0x012B, r15
     f9e:	e0 92 2a 01 	sts	0x012A, r14

		if( xConstTickCount == ( TickType_t ) 0U )
     fa2:	e1 14       	cp	r14, r1
     fa4:	f1 04       	cpc	r15, r1
     fa6:	b9 f4       	brne	.+46     	; 0xfd6 <xTaskIncrementTick+0x62>
		{
			taskSWITCH_DELAYED_LISTS();
     fa8:	80 91 30 01 	lds	r24, 0x0130
     fac:	90 91 31 01 	lds	r25, 0x0131
     fb0:	20 91 2e 01 	lds	r18, 0x012E
     fb4:	30 91 2f 01 	lds	r19, 0x012F
     fb8:	30 93 31 01 	sts	0x0131, r19
     fbc:	20 93 30 01 	sts	0x0130, r18
     fc0:	90 93 2f 01 	sts	0x012F, r25
     fc4:	80 93 2e 01 	sts	0x012E, r24
     fc8:	80 91 25 01 	lds	r24, 0x0125
     fcc:	8f 5f       	subi	r24, 0xFF	; 255
     fce:	80 93 25 01 	sts	0x0125, r24
     fd2:	0e 94 d6 05 	call	0xbac	; 0xbac <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     fd6:	80 91 23 01 	lds	r24, 0x0123
     fda:	90 91 24 01 	lds	r25, 0x0124
     fde:	e8 16       	cp	r14, r24
     fe0:	f9 06       	cpc	r15, r25
     fe2:	20 f4       	brcc	.+8      	; 0xfec <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     fe4:	d1 2c       	mov	r13, r1
     fe6:	54 c0       	rjmp	.+168    	; 0x1090 <xTaskIncrementTick+0x11c>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
     fe8:	dc 2c       	mov	r13, r12
     fea:	03 c0       	rjmp	.+6      	; 0xff2 <xTaskIncrementTick+0x7e>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     fec:	d1 2c       	mov	r13, r1
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
     fee:	cc 24       	eor	r12, r12
     ff0:	c3 94       	inc	r12
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     ff2:	e0 91 30 01 	lds	r30, 0x0130
     ff6:	f0 91 31 01 	lds	r31, 0x0131
     ffa:	80 81       	ld	r24, Z
     ffc:	81 11       	cpse	r24, r1
     ffe:	07 c0       	rjmp	.+14     	; 0x100e <xTaskIncrementTick+0x9a>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1000:	8f ef       	ldi	r24, 0xFF	; 255
    1002:	9f ef       	ldi	r25, 0xFF	; 255
    1004:	90 93 24 01 	sts	0x0124, r25
    1008:	80 93 23 01 	sts	0x0123, r24
					break;
    100c:	41 c0       	rjmp	.+130    	; 0x1090 <xTaskIncrementTick+0x11c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    100e:	e0 91 30 01 	lds	r30, 0x0130
    1012:	f0 91 31 01 	lds	r31, 0x0131
    1016:	05 80       	ldd	r0, Z+5	; 0x05
    1018:	f6 81       	ldd	r31, Z+6	; 0x06
    101a:	e0 2d       	mov	r30, r0
    101c:	c6 81       	ldd	r28, Z+6	; 0x06
    101e:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1020:	2a 81       	ldd	r18, Y+2	; 0x02
    1022:	3b 81       	ldd	r19, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    1024:	e2 16       	cp	r14, r18
    1026:	f3 06       	cpc	r15, r19
    1028:	28 f4       	brcc	.+10     	; 0x1034 <xTaskIncrementTick+0xc0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    102a:	30 93 24 01 	sts	0x0124, r19
    102e:	20 93 23 01 	sts	0x0123, r18
						break;
    1032:	2e c0       	rjmp	.+92     	; 0x1090 <xTaskIncrementTick+0x11c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1034:	8e 01       	movw	r16, r28
    1036:	0e 5f       	subi	r16, 0xFE	; 254
    1038:	1f 4f       	sbci	r17, 0xFF	; 255
    103a:	c8 01       	movw	r24, r16
    103c:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1040:	8c 89       	ldd	r24, Y+20	; 0x14
    1042:	9d 89       	ldd	r25, Y+21	; 0x15
    1044:	89 2b       	or	r24, r25
    1046:	21 f0       	breq	.+8      	; 0x1050 <xTaskIncrementTick+0xdc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1048:	ce 01       	movw	r24, r28
    104a:	0c 96       	adiw	r24, 0x0c	; 12
    104c:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    1050:	2e 89       	ldd	r18, Y+22	; 0x16
    1052:	80 91 29 01 	lds	r24, 0x0129
    1056:	82 17       	cp	r24, r18
    1058:	10 f4       	brcc	.+4      	; 0x105e <xTaskIncrementTick+0xea>
    105a:	20 93 29 01 	sts	0x0129, r18
    105e:	30 e0       	ldi	r19, 0x00	; 0
    1060:	c9 01       	movw	r24, r18
    1062:	88 0f       	add	r24, r24
    1064:	99 1f       	adc	r25, r25
    1066:	88 0f       	add	r24, r24
    1068:	99 1f       	adc	r25, r25
    106a:	88 0f       	add	r24, r24
    106c:	99 1f       	adc	r25, r25
    106e:	82 0f       	add	r24, r18
    1070:	93 1f       	adc	r25, r19
    1072:	b8 01       	movw	r22, r16
    1074:	8b 5c       	subi	r24, 0xCB	; 203
    1076:	9e 4f       	sbci	r25, 0xFE	; 254
    1078:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    107c:	e0 91 32 01 	lds	r30, 0x0132
    1080:	f0 91 33 01 	lds	r31, 0x0133
    1084:	9e 89       	ldd	r25, Y+22	; 0x16
    1086:	86 89       	ldd	r24, Z+22	; 0x16
    1088:	98 17       	cp	r25, r24
    108a:	08 f0       	brcs	.+2      	; 0x108e <xTaskIncrementTick+0x11a>
    108c:	ad cf       	rjmp	.-166    	; 0xfe8 <xTaskIncrementTick+0x74>
    108e:	b1 cf       	rjmp	.-158    	; 0xff2 <xTaskIncrementTick+0x7e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1090:	e0 91 32 01 	lds	r30, 0x0132
    1094:	f0 91 33 01 	lds	r31, 0x0133
    1098:	86 89       	ldd	r24, Z+22	; 0x16
    109a:	90 e0       	ldi	r25, 0x00	; 0
    109c:	fc 01       	movw	r30, r24
    109e:	ee 0f       	add	r30, r30
    10a0:	ff 1f       	adc	r31, r31
    10a2:	ee 0f       	add	r30, r30
    10a4:	ff 1f       	adc	r31, r31
    10a6:	ee 0f       	add	r30, r30
    10a8:	ff 1f       	adc	r31, r31
    10aa:	8e 0f       	add	r24, r30
    10ac:	9f 1f       	adc	r25, r31
    10ae:	fc 01       	movw	r30, r24
    10b0:	eb 5c       	subi	r30, 0xCB	; 203
    10b2:	fe 4f       	sbci	r31, 0xFE	; 254
    10b4:	80 81       	ld	r24, Z
    10b6:	82 30       	cpi	r24, 0x02	; 2
    10b8:	40 f4       	brcc	.+16     	; 0x10ca <xTaskIncrementTick+0x156>
    10ba:	09 c0       	rjmp	.+18     	; 0x10ce <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    10bc:	80 91 27 01 	lds	r24, 0x0127
    10c0:	8f 5f       	subi	r24, 0xFF	; 255
    10c2:	80 93 27 01 	sts	0x0127, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    10c6:	d1 2c       	mov	r13, r1
    10c8:	02 c0       	rjmp	.+4      	; 0x10ce <xTaskIncrementTick+0x15a>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    10ca:	dd 24       	eor	r13, r13
    10cc:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    10ce:	80 91 26 01 	lds	r24, 0x0126
    10d2:	88 23       	and	r24, r24
    10d4:	11 f0       	breq	.+4      	; 0x10da <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
    10d6:	dd 24       	eor	r13, r13
    10d8:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    10da:	8d 2d       	mov	r24, r13
    10dc:	df 91       	pop	r29
    10de:	cf 91       	pop	r28
    10e0:	1f 91       	pop	r17
    10e2:	0f 91       	pop	r16
    10e4:	ff 90       	pop	r15
    10e6:	ef 90       	pop	r14
    10e8:	df 90       	pop	r13
    10ea:	cf 90       	pop	r12
    10ec:	08 95       	ret

000010ee <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    10ee:	df 92       	push	r13
    10f0:	ef 92       	push	r14
    10f2:	ff 92       	push	r15
    10f4:	0f 93       	push	r16
    10f6:	1f 93       	push	r17
    10f8:	cf 93       	push	r28
    10fa:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    10fc:	0f b6       	in	r0, 0x3f	; 63
    10fe:	f8 94       	cli
    1100:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1102:	80 91 22 01 	lds	r24, 0x0122
    1106:	81 50       	subi	r24, 0x01	; 1
    1108:	80 93 22 01 	sts	0x0122, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    110c:	80 91 22 01 	lds	r24, 0x0122
    1110:	81 11       	cpse	r24, r1
    1112:	5e c0       	rjmp	.+188    	; 0x11d0 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1114:	80 91 2c 01 	lds	r24, 0x012C
    1118:	81 11       	cpse	r24, r1
    111a:	32 c0       	rjmp	.+100    	; 0x1180 <xTaskResumeAll+0x92>
    111c:	5c c0       	rjmp	.+184    	; 0x11d6 <xTaskResumeAll+0xe8>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    111e:	e0 91 70 01 	lds	r30, 0x0170
    1122:	f0 91 71 01 	lds	r31, 0x0171
    1126:	c6 81       	ldd	r28, Z+6	; 0x06
    1128:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    112a:	ce 01       	movw	r24, r28
    112c:	0c 96       	adiw	r24, 0x0c	; 12
    112e:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1132:	8e 01       	movw	r16, r28
    1134:	0e 5f       	subi	r16, 0xFE	; 254
    1136:	1f 4f       	sbci	r17, 0xFF	; 255
    1138:	c8 01       	movw	r24, r16
    113a:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    113e:	8e 89       	ldd	r24, Y+22	; 0x16
    1140:	90 91 29 01 	lds	r25, 0x0129
    1144:	98 17       	cp	r25, r24
    1146:	10 f4       	brcc	.+4      	; 0x114c <xTaskResumeAll+0x5e>
    1148:	80 93 29 01 	sts	0x0129, r24
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	9c 01       	movw	r18, r24
    1150:	22 0f       	add	r18, r18
    1152:	33 1f       	adc	r19, r19
    1154:	22 0f       	add	r18, r18
    1156:	33 1f       	adc	r19, r19
    1158:	22 0f       	add	r18, r18
    115a:	33 1f       	adc	r19, r19
    115c:	82 0f       	add	r24, r18
    115e:	93 1f       	adc	r25, r19
    1160:	b8 01       	movw	r22, r16
    1162:	8b 5c       	subi	r24, 0xCB	; 203
    1164:	9e 4f       	sbci	r25, 0xFE	; 254
    1166:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    116a:	e0 91 32 01 	lds	r30, 0x0132
    116e:	f0 91 33 01 	lds	r31, 0x0133
    1172:	9e 89       	ldd	r25, Y+22	; 0x16
    1174:	86 89       	ldd	r24, Z+22	; 0x16
    1176:	98 17       	cp	r25, r24
    1178:	68 f0       	brcs	.+26     	; 0x1194 <xTaskResumeAll+0xa6>
					{
						xYieldPending = pdTRUE;
    117a:	d0 92 26 01 	sts	0x0126, r13
    117e:	0a c0       	rjmp	.+20     	; 0x1194 <xTaskResumeAll+0xa6>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1180:	c0 e0       	ldi	r28, 0x00	; 0
    1182:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1184:	0f 2e       	mov	r0, r31
    1186:	fb e6       	ldi	r31, 0x6B	; 107
    1188:	ef 2e       	mov	r14, r31
    118a:	f1 e0       	ldi	r31, 0x01	; 1
    118c:	ff 2e       	mov	r15, r31
    118e:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    1190:	dd 24       	eor	r13, r13
    1192:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1194:	f7 01       	movw	r30, r14
    1196:	80 81       	ld	r24, Z
    1198:	81 11       	cpse	r24, r1
    119a:	c1 cf       	rjmp	.-126    	; 0x111e <xTaskResumeAll+0x30>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    119c:	cd 2b       	or	r28, r29
    119e:	11 f0       	breq	.+4      	; 0x11a4 <xTaskResumeAll+0xb6>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    11a0:	0e 94 d6 05 	call	0xbac	; 0xbac <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    11a4:	c0 91 27 01 	lds	r28, 0x0127

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    11a8:	cc 23       	and	r28, r28
    11aa:	51 f0       	breq	.+20     	; 0x11c0 <xTaskResumeAll+0xd2>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    11ac:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    11ae:	0e 94 ba 07 	call	0xf74	; 0xf74 <xTaskIncrementTick>
    11b2:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
    11b4:	d0 93 26 01 	sts	0x0126, r29
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    11b8:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    11ba:	c9 f7       	brne	.-14     	; 0x11ae <xTaskResumeAll+0xc0>

						uxPendedTicks = 0;
    11bc:	10 92 27 01 	sts	0x0127, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    11c0:	80 91 26 01 	lds	r24, 0x0126
    11c4:	88 23       	and	r24, r24
    11c6:	31 f0       	breq	.+12     	; 0x11d4 <xTaskResumeAll+0xe6>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    11c8:	0e 94 21 02 	call	0x442	; 0x442 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	03 c0       	rjmp	.+6      	; 0x11d6 <xTaskResumeAll+0xe8>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    11d0:	80 e0       	ldi	r24, 0x00	; 0
    11d2:	01 c0       	rjmp	.+2      	; 0x11d6 <xTaskResumeAll+0xe8>
    11d4:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    11d6:	0f 90       	pop	r0
    11d8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    11da:	df 91       	pop	r29
    11dc:	cf 91       	pop	r28
    11de:	1f 91       	pop	r17
    11e0:	0f 91       	pop	r16
    11e2:	ff 90       	pop	r15
    11e4:	ef 90       	pop	r14
    11e6:	df 90       	pop	r13
    11e8:	08 95       	ret

000011ea <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    11ea:	c4 e7       	ldi	r28, 0x74	; 116
    11ec:	d1 e0       	ldi	r29, 0x01	; 1

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    11ee:	0f 2e       	mov	r0, r31
    11f0:	f5 e3       	ldi	r31, 0x35	; 53
    11f2:	ef 2e       	mov	r14, r31
    11f4:	f1 e0       	ldi	r31, 0x01	; 1
    11f6:	ff 2e       	mov	r15, r31
    11f8:	f0 2d       	mov	r31, r0
    11fa:	23 c0       	rjmp	.+70     	; 0x1242 <prvIdleTask+0x58>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    11fc:	0e 94 a8 07 	call	0xf50	; 0xf50 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1200:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
    1202:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1206:	11 23       	and	r17, r17
    1208:	e1 f0       	breq	.+56     	; 0x1242 <prvIdleTask+0x58>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    120a:	0f b6       	in	r0, 0x3f	; 63
    120c:	f8 94       	cli
    120e:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1210:	e0 91 79 01 	lds	r30, 0x0179
    1214:	f0 91 7a 01 	lds	r31, 0x017A
    1218:	06 81       	ldd	r16, Z+6	; 0x06
    121a:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    121c:	c8 01       	movw	r24, r16
    121e:	02 96       	adiw	r24, 0x02	; 2
    1220:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>
					--uxCurrentNumberOfTasks;
    1224:	80 91 2c 01 	lds	r24, 0x012C
    1228:	81 50       	subi	r24, 0x01	; 1
    122a:	80 93 2c 01 	sts	0x012C, r24
					--uxDeletedTasksWaitingCleanUp;
    122e:	80 91 2d 01 	lds	r24, 0x012D
    1232:	81 50       	subi	r24, 0x01	; 1
    1234:	80 93 2d 01 	sts	0x012D, r24
				}
				taskEXIT_CRITICAL();
    1238:	0f 90       	pop	r0
    123a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    123c:	c8 01       	movw	r24, r16
    123e:	0e 94 4d 06 	call	0xc9a	; 0xc9a <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1242:	80 91 2d 01 	lds	r24, 0x012D
    1246:	81 11       	cpse	r24, r1
    1248:	d9 cf       	rjmp	.-78     	; 0x11fc <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    124a:	f7 01       	movw	r30, r14
    124c:	80 81       	ld	r24, Z
    124e:	82 30       	cpi	r24, 0x02	; 2
    1250:	10 f0       	brcs	.+4      	; 0x1256 <prvIdleTask+0x6c>
			{
				taskYIELD();
    1252:	0e 94 21 02 	call	0x442	; 0x442 <vPortYield>
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			//vApplicationIdleHook();//////////////////////////////////////////nnnnnnnnnnn
			vTaskStartScheduler();
    1256:	0e 94 7a 07 	call	0xef4	; 0xef4 <vTaskStartScheduler>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    125a:	f3 cf       	rjmp	.-26     	; 0x1242 <prvIdleTask+0x58>

0000125c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    125c:	80 91 22 01 	lds	r24, 0x0122
    1260:	88 23       	and	r24, r24
    1262:	21 f0       	breq	.+8      	; 0x126c <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1264:	81 e0       	ldi	r24, 0x01	; 1
    1266:	80 93 26 01 	sts	0x0126, r24
    126a:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    126c:	10 92 26 01 	sts	0x0126, r1
		/* Check for stack overflow, if configured. */
//		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1270:	20 91 29 01 	lds	r18, 0x0129
    1274:	82 2f       	mov	r24, r18
    1276:	90 e0       	ldi	r25, 0x00	; 0
    1278:	fc 01       	movw	r30, r24
    127a:	ee 0f       	add	r30, r30
    127c:	ff 1f       	adc	r31, r31
    127e:	ee 0f       	add	r30, r30
    1280:	ff 1f       	adc	r31, r31
    1282:	ee 0f       	add	r30, r30
    1284:	ff 1f       	adc	r31, r31
    1286:	e8 0f       	add	r30, r24
    1288:	f9 1f       	adc	r31, r25
    128a:	eb 5c       	subi	r30, 0xCB	; 203
    128c:	fe 4f       	sbci	r31, 0xFE	; 254
    128e:	30 81       	ld	r19, Z
    1290:	31 11       	cpse	r19, r1
    1292:	11 c0       	rjmp	.+34     	; 0x12b6 <vTaskSwitchContext+0x5a>
    1294:	21 50       	subi	r18, 0x01	; 1
    1296:	82 2f       	mov	r24, r18
    1298:	90 e0       	ldi	r25, 0x00	; 0
    129a:	fc 01       	movw	r30, r24
    129c:	ee 0f       	add	r30, r30
    129e:	ff 1f       	adc	r31, r31
    12a0:	ee 0f       	add	r30, r30
    12a2:	ff 1f       	adc	r31, r31
    12a4:	ee 0f       	add	r30, r30
    12a6:	ff 1f       	adc	r31, r31
    12a8:	e8 0f       	add	r30, r24
    12aa:	f9 1f       	adc	r31, r25
    12ac:	eb 5c       	subi	r30, 0xCB	; 203
    12ae:	fe 4f       	sbci	r31, 0xFE	; 254
    12b0:	30 81       	ld	r19, Z
    12b2:	33 23       	and	r19, r19
    12b4:	79 f3       	breq	.-34     	; 0x1294 <vTaskSwitchContext+0x38>
    12b6:	fc 01       	movw	r30, r24
    12b8:	ee 0f       	add	r30, r30
    12ba:	ff 1f       	adc	r31, r31
    12bc:	ee 0f       	add	r30, r30
    12be:	ff 1f       	adc	r31, r31
    12c0:	ee 0f       	add	r30, r30
    12c2:	ff 1f       	adc	r31, r31
    12c4:	8e 0f       	add	r24, r30
    12c6:	9f 1f       	adc	r25, r31
    12c8:	fc 01       	movw	r30, r24
    12ca:	eb 5c       	subi	r30, 0xCB	; 203
    12cc:	fe 4f       	sbci	r31, 0xFE	; 254
    12ce:	a1 81       	ldd	r26, Z+1	; 0x01
    12d0:	b2 81       	ldd	r27, Z+2	; 0x02
    12d2:	12 96       	adiw	r26, 0x02	; 2
    12d4:	0d 90       	ld	r0, X+
    12d6:	bc 91       	ld	r27, X
    12d8:	a0 2d       	mov	r26, r0
    12da:	b2 83       	std	Z+2, r27	; 0x02
    12dc:	a1 83       	std	Z+1, r26	; 0x01
    12de:	cf 01       	movw	r24, r30
    12e0:	03 96       	adiw	r24, 0x03	; 3
    12e2:	a8 17       	cp	r26, r24
    12e4:	b9 07       	cpc	r27, r25
    12e6:	31 f4       	brne	.+12     	; 0x12f4 <vTaskSwitchContext+0x98>
    12e8:	12 96       	adiw	r26, 0x02	; 2
    12ea:	8d 91       	ld	r24, X+
    12ec:	9c 91       	ld	r25, X
    12ee:	13 97       	sbiw	r26, 0x03	; 3
    12f0:	92 83       	std	Z+2, r25	; 0x02
    12f2:	81 83       	std	Z+1, r24	; 0x01
    12f4:	01 80       	ldd	r0, Z+1	; 0x01
    12f6:	f2 81       	ldd	r31, Z+2	; 0x02
    12f8:	e0 2d       	mov	r30, r0
    12fa:	86 81       	ldd	r24, Z+6	; 0x06
    12fc:	97 81       	ldd	r25, Z+7	; 0x07
    12fe:	90 93 33 01 	sts	0x0133, r25
    1302:	80 93 32 01 	sts	0x0132, r24
    1306:	20 93 29 01 	sts	0x0129, r18
    130a:	08 95       	ret

0000130c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    130c:	cf 93       	push	r28
    130e:	df 93       	push	r29
    1310:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1312:	60 91 32 01 	lds	r22, 0x0132
    1316:	70 91 33 01 	lds	r23, 0x0133
    131a:	64 5f       	subi	r22, 0xF4	; 244
    131c:	7f 4f       	sbci	r23, 0xFF	; 255
    131e:	0e 94 fd 00 	call	0x1fa	; 0x1fa <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1322:	61 e0       	ldi	r22, 0x01	; 1
    1324:	ce 01       	movw	r24, r28
    1326:	0e 94 f5 05 	call	0xbea	; 0xbea <prvAddCurrentTaskToDelayedList>
}
    132a:	df 91       	pop	r29
    132c:	cf 91       	pop	r28
    132e:	08 95       	ret

00001330 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    1330:	1f 93       	push	r17
    1332:	cf 93       	push	r28
    1334:	df 93       	push	r29
    1336:	eb 01       	movw	r28, r22
    1338:	14 2f       	mov	r17, r20

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    133a:	20 91 32 01 	lds	r18, 0x0132
    133e:	30 91 33 01 	lds	r19, 0x0133
    1342:	b9 01       	movw	r22, r18
    1344:	64 5f       	subi	r22, 0xF4	; 244
    1346:	7f 4f       	sbci	r23, 0xFF	; 255
    1348:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
    134c:	11 23       	and	r17, r17
    134e:	11 f0       	breq	.+4      	; 0x1354 <vTaskPlaceOnEventListRestricted+0x24>
		{
			xTicksToWait = portMAX_DELAY;
    1350:	cf ef       	ldi	r28, 0xFF	; 255
    1352:	df ef       	ldi	r29, 0xFF	; 255
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    1354:	61 2f       	mov	r22, r17
    1356:	ce 01       	movw	r24, r28
    1358:	0e 94 f5 05 	call	0xbea	; 0xbea <prvAddCurrentTaskToDelayedList>
	}
    135c:	df 91       	pop	r29
    135e:	cf 91       	pop	r28
    1360:	1f 91       	pop	r17
    1362:	08 95       	ret

00001364 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1364:	0f 93       	push	r16
    1366:	1f 93       	push	r17
    1368:	cf 93       	push	r28
    136a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    136c:	dc 01       	movw	r26, r24
    136e:	15 96       	adiw	r26, 0x05	; 5
    1370:	ed 91       	ld	r30, X+
    1372:	fc 91       	ld	r31, X
    1374:	16 97       	sbiw	r26, 0x06	; 6
    1376:	c6 81       	ldd	r28, Z+6	; 0x06
    1378:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    137a:	8e 01       	movw	r16, r28
    137c:	04 5f       	subi	r16, 0xF4	; 244
    137e:	1f 4f       	sbci	r17, 0xFF	; 255
    1380:	c8 01       	movw	r24, r16
    1382:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1386:	80 91 22 01 	lds	r24, 0x0122
    138a:	81 11       	cpse	r24, r1
    138c:	1d c0       	rjmp	.+58     	; 0x13c8 <xTaskRemoveFromEventList+0x64>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    138e:	8e 01       	movw	r16, r28
    1390:	0e 5f       	subi	r16, 0xFE	; 254
    1392:	1f 4f       	sbci	r17, 0xFF	; 255
    1394:	c8 01       	movw	r24, r16
    1396:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    139a:	8e 89       	ldd	r24, Y+22	; 0x16
    139c:	90 91 29 01 	lds	r25, 0x0129
    13a0:	98 17       	cp	r25, r24
    13a2:	10 f4       	brcc	.+4      	; 0x13a8 <xTaskRemoveFromEventList+0x44>
    13a4:	80 93 29 01 	sts	0x0129, r24
    13a8:	90 e0       	ldi	r25, 0x00	; 0
    13aa:	9c 01       	movw	r18, r24
    13ac:	22 0f       	add	r18, r18
    13ae:	33 1f       	adc	r19, r19
    13b0:	22 0f       	add	r18, r18
    13b2:	33 1f       	adc	r19, r19
    13b4:	22 0f       	add	r18, r18
    13b6:	33 1f       	adc	r19, r19
    13b8:	82 0f       	add	r24, r18
    13ba:	93 1f       	adc	r25, r19
    13bc:	b8 01       	movw	r22, r16
    13be:	8b 5c       	subi	r24, 0xCB	; 203
    13c0:	9e 4f       	sbci	r25, 0xFE	; 254
    13c2:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <vListInsertEnd>
    13c6:	05 c0       	rjmp	.+10     	; 0x13d2 <xTaskRemoveFromEventList+0x6e>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    13c8:	b8 01       	movw	r22, r16
    13ca:	8b e6       	ldi	r24, 0x6B	; 107
    13cc:	91 e0       	ldi	r25, 0x01	; 1
    13ce:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    13d2:	e0 91 32 01 	lds	r30, 0x0132
    13d6:	f0 91 33 01 	lds	r31, 0x0133
    13da:	9e 89       	ldd	r25, Y+22	; 0x16
    13dc:	86 89       	ldd	r24, Z+22	; 0x16
    13de:	89 17       	cp	r24, r25
    13e0:	20 f4       	brcc	.+8      	; 0x13ea <xTaskRemoveFromEventList+0x86>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    13e2:	81 e0       	ldi	r24, 0x01	; 1
    13e4:	80 93 26 01 	sts	0x0126, r24
    13e8:	01 c0       	rjmp	.+2      	; 0x13ec <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		xReturn = pdFALSE;
    13ea:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    13ec:	df 91       	pop	r29
    13ee:	cf 91       	pop	r28
    13f0:	1f 91       	pop	r17
    13f2:	0f 91       	pop	r16
    13f4:	08 95       	ret

000013f6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    13f6:	20 91 25 01 	lds	r18, 0x0125
    13fa:	fc 01       	movw	r30, r24
    13fc:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    13fe:	20 91 2a 01 	lds	r18, 0x012A
    1402:	30 91 2b 01 	lds	r19, 0x012B
    1406:	32 83       	std	Z+2, r19	; 0x02
    1408:	21 83       	std	Z+1, r18	; 0x01
    140a:	08 95       	ret

0000140c <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    140c:	0f b6       	in	r0, 0x3f	; 63
    140e:	f8 94       	cli
    1410:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1412:	40 91 2a 01 	lds	r20, 0x012A
    1416:	50 91 2b 01 	lds	r21, 0x012B
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    141a:	db 01       	movw	r26, r22
    141c:	2d 91       	ld	r18, X+
    141e:	3c 91       	ld	r19, X
    1420:	2f 3f       	cpi	r18, 0xFF	; 255
    1422:	bf ef       	ldi	r27, 0xFF	; 255
    1424:	3b 07       	cpc	r19, r27
    1426:	19 f1       	breq	.+70     	; 0x146e <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1428:	e0 91 25 01 	lds	r30, 0x0125
    142c:	dc 01       	movw	r26, r24
    142e:	fc 91       	ld	r31, X
    1430:	fe 17       	cp	r31, r30
    1432:	39 f0       	breq	.+14     	; 0x1442 <xTaskCheckForTimeOut+0x36>
    1434:	11 96       	adiw	r26, 0x01	; 1
    1436:	ed 91       	ld	r30, X+
    1438:	fc 91       	ld	r31, X
    143a:	12 97       	sbiw	r26, 0x02	; 2
    143c:	4e 17       	cp	r20, r30
    143e:	5f 07       	cpc	r21, r31
    1440:	c0 f4       	brcc	.+48     	; 0x1472 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1442:	dc 01       	movw	r26, r24
    1444:	11 96       	adiw	r26, 0x01	; 1
    1446:	ed 91       	ld	r30, X+
    1448:	fc 91       	ld	r31, X
    144a:	12 97       	sbiw	r26, 0x02	; 2
    144c:	da 01       	movw	r26, r20
    144e:	ae 1b       	sub	r26, r30
    1450:	bf 0b       	sbc	r27, r31
    1452:	a2 17       	cp	r26, r18
    1454:	b3 07       	cpc	r27, r19
    1456:	78 f4       	brcc	.+30     	; 0x1476 <xTaskCheckForTimeOut+0x6a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1458:	e4 1b       	sub	r30, r20
    145a:	f5 0b       	sbc	r31, r21
    145c:	2e 0f       	add	r18, r30
    145e:	3f 1f       	adc	r19, r31
    1460:	fb 01       	movw	r30, r22
    1462:	31 83       	std	Z+1, r19	; 0x01
    1464:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    1466:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    146a:	80 e0       	ldi	r24, 0x00	; 0
    146c:	05 c0       	rjmp	.+10     	; 0x1478 <xTaskCheckForTimeOut+0x6c>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    146e:	80 e0       	ldi	r24, 0x00	; 0
    1470:	03 c0       	rjmp	.+6      	; 0x1478 <xTaskCheckForTimeOut+0x6c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1472:	81 e0       	ldi	r24, 0x01	; 1
    1474:	01 c0       	rjmp	.+2      	; 0x1478 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1476:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1478:	0f 90       	pop	r0
    147a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    147c:	08 95       	ret

0000147e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    147e:	81 e0       	ldi	r24, 0x01	; 1
    1480:	80 93 26 01 	sts	0x0126, r24
    1484:	08 95       	ret

00001486 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    1486:	80 91 28 01 	lds	r24, 0x0128
    148a:	88 23       	and	r24, r24
    148c:	31 f0       	breq	.+12     	; 0x149a <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    148e:	80 91 22 01 	lds	r24, 0x0122
    1492:	81 11       	cpse	r24, r1
    1494:	04 c0       	rjmp	.+8      	; 0x149e <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
    1496:	82 e0       	ldi	r24, 0x02	; 2
    1498:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    149a:	81 e0       	ldi	r24, 0x01	; 1
    149c:	08 95       	ret
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    149e:	80 e0       	ldi	r24, 0x00	; 0
			}
		}

		return xReturn;
	}
    14a0:	08 95       	ret

000014a2 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    14a2:	0f 93       	push	r16
    14a4:	1f 93       	push	r17
    14a6:	cf 93       	push	r28
    14a8:	df 93       	push	r29
    14aa:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    14ac:	00 97       	sbiw	r24, 0x00	; 0
    14ae:	09 f4       	brne	.+2      	; 0x14b2 <vTaskPriorityInherit+0x10>
    14b0:	51 c0       	rjmp	.+162    	; 0x1554 <vTaskPriorityInherit+0xb2>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    14b2:	8e 89       	ldd	r24, Y+22	; 0x16
    14b4:	e0 91 32 01 	lds	r30, 0x0132
    14b8:	f0 91 33 01 	lds	r31, 0x0133
    14bc:	96 89       	ldd	r25, Z+22	; 0x16
    14be:	89 17       	cp	r24, r25
    14c0:	08 f0       	brcs	.+2      	; 0x14c4 <vTaskPriorityInherit+0x22>
    14c2:	48 c0       	rjmp	.+144    	; 0x1554 <vTaskPriorityInherit+0xb2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    14c4:	2c 85       	ldd	r18, Y+12	; 0x0c
    14c6:	3d 85       	ldd	r19, Y+13	; 0x0d
    14c8:	33 23       	and	r19, r19
    14ca:	5c f0       	brlt	.+22     	; 0x14e2 <vTaskPriorityInherit+0x40>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14cc:	e0 91 32 01 	lds	r30, 0x0132
    14d0:	f0 91 33 01 	lds	r31, 0x0133
    14d4:	96 89       	ldd	r25, Z+22	; 0x16
    14d6:	24 e0       	ldi	r18, 0x04	; 4
    14d8:	30 e0       	ldi	r19, 0x00	; 0
    14da:	29 1b       	sub	r18, r25
    14dc:	31 09       	sbc	r19, r1
    14de:	3d 87       	std	Y+13, r19	; 0x0d
    14e0:	2c 87       	std	Y+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	9c 01       	movw	r18, r24
    14e6:	22 0f       	add	r18, r18
    14e8:	33 1f       	adc	r19, r19
    14ea:	22 0f       	add	r18, r18
    14ec:	33 1f       	adc	r19, r19
    14ee:	22 0f       	add	r18, r18
    14f0:	33 1f       	adc	r19, r19
    14f2:	82 0f       	add	r24, r18
    14f4:	93 1f       	adc	r25, r19
    14f6:	8b 5c       	subi	r24, 0xCB	; 203
    14f8:	9e 4f       	sbci	r25, 0xFE	; 254
    14fa:	2a 85       	ldd	r18, Y+10	; 0x0a
    14fc:	3b 85       	ldd	r19, Y+11	; 0x0b
    14fe:	28 17       	cp	r18, r24
    1500:	39 07       	cpc	r19, r25
    1502:	11 f5       	brne	.+68     	; 0x1548 <vTaskPriorityInherit+0xa6>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1504:	8e 01       	movw	r16, r28
    1506:	0e 5f       	subi	r16, 0xFE	; 254
    1508:	1f 4f       	sbci	r17, 0xFF	; 255
    150a:	c8 01       	movw	r24, r16
    150c:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1510:	e0 91 32 01 	lds	r30, 0x0132
    1514:	f0 91 33 01 	lds	r31, 0x0133
    1518:	86 89       	ldd	r24, Z+22	; 0x16
    151a:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    151c:	90 91 29 01 	lds	r25, 0x0129
    1520:	98 17       	cp	r25, r24
    1522:	10 f4       	brcc	.+4      	; 0x1528 <vTaskPriorityInherit+0x86>
    1524:	80 93 29 01 	sts	0x0129, r24
    1528:	90 e0       	ldi	r25, 0x00	; 0
    152a:	9c 01       	movw	r18, r24
    152c:	22 0f       	add	r18, r18
    152e:	33 1f       	adc	r19, r19
    1530:	22 0f       	add	r18, r18
    1532:	33 1f       	adc	r19, r19
    1534:	22 0f       	add	r18, r18
    1536:	33 1f       	adc	r19, r19
    1538:	82 0f       	add	r24, r18
    153a:	93 1f       	adc	r25, r19
    153c:	b8 01       	movw	r22, r16
    153e:	8b 5c       	subi	r24, 0xCB	; 203
    1540:	9e 4f       	sbci	r25, 0xFE	; 254
    1542:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <vListInsertEnd>
    1546:	06 c0       	rjmp	.+12     	; 0x1554 <vTaskPriorityInherit+0xb2>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1548:	e0 91 32 01 	lds	r30, 0x0132
    154c:	f0 91 33 01 	lds	r31, 0x0133
    1550:	86 89       	ldd	r24, Z+22	; 0x16
    1552:	8e 8b       	std	Y+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1554:	df 91       	pop	r29
    1556:	cf 91       	pop	r28
    1558:	1f 91       	pop	r17
    155a:	0f 91       	pop	r16
    155c:	08 95       	ret

0000155e <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    155e:	0f 93       	push	r16
    1560:	1f 93       	push	r17
    1562:	cf 93       	push	r28
    1564:	df 93       	push	r29
    1566:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    1568:	00 97       	sbiw	r24, 0x00	; 0
    156a:	71 f1       	breq	.+92     	; 0x15c8 <xTaskPriorityDisinherit+0x6a>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    156c:	8a a1       	ldd	r24, Y+34	; 0x22
    156e:	81 50       	subi	r24, 0x01	; 1
    1570:	8a a3       	std	Y+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1572:	2e 89       	ldd	r18, Y+22	; 0x16
    1574:	99 a1       	ldd	r25, Y+33	; 0x21
    1576:	29 17       	cp	r18, r25
    1578:	49 f1       	breq	.+82     	; 0x15cc <xTaskPriorityDisinherit+0x6e>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    157a:	81 11       	cpse	r24, r1
    157c:	29 c0       	rjmp	.+82     	; 0x15d0 <xTaskPriorityDisinherit+0x72>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    157e:	8e 01       	movw	r16, r28
    1580:	0e 5f       	subi	r16, 0xFE	; 254
    1582:	1f 4f       	sbci	r17, 0xFF	; 255
    1584:	c8 01       	movw	r24, r16
    1586:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    158a:	89 a1       	ldd	r24, Y+33	; 0x21
    158c:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    158e:	24 e0       	ldi	r18, 0x04	; 4
    1590:	30 e0       	ldi	r19, 0x00	; 0
    1592:	28 1b       	sub	r18, r24
    1594:	31 09       	sbc	r19, r1
    1596:	3d 87       	std	Y+13, r19	; 0x0d
    1598:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    159a:	90 91 29 01 	lds	r25, 0x0129
    159e:	98 17       	cp	r25, r24
    15a0:	10 f4       	brcc	.+4      	; 0x15a6 <xTaskPriorityDisinherit+0x48>
    15a2:	80 93 29 01 	sts	0x0129, r24
    15a6:	90 e0       	ldi	r25, 0x00	; 0
    15a8:	9c 01       	movw	r18, r24
    15aa:	22 0f       	add	r18, r18
    15ac:	33 1f       	adc	r19, r19
    15ae:	22 0f       	add	r18, r18
    15b0:	33 1f       	adc	r19, r19
    15b2:	22 0f       	add	r18, r18
    15b4:	33 1f       	adc	r19, r19
    15b6:	82 0f       	add	r24, r18
    15b8:	93 1f       	adc	r25, r19
    15ba:	b8 01       	movw	r22, r16
    15bc:	8b 5c       	subi	r24, 0xCB	; 203
    15be:	9e 4f       	sbci	r25, 0xFE	; 254
    15c0:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    15c4:	81 e0       	ldi	r24, 0x01	; 1
    15c6:	05 c0       	rjmp	.+10     	; 0x15d2 <xTaskPriorityDisinherit+0x74>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    15c8:	80 e0       	ldi	r24, 0x00	; 0
    15ca:	03 c0       	rjmp	.+6      	; 0x15d2 <xTaskPriorityDisinherit+0x74>
    15cc:	80 e0       	ldi	r24, 0x00	; 0
    15ce:	01 c0       	rjmp	.+2      	; 0x15d2 <xTaskPriorityDisinherit+0x74>
    15d0:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    15d2:	df 91       	pop	r29
    15d4:	cf 91       	pop	r28
    15d6:	1f 91       	pop	r17
    15d8:	0f 91       	pop	r16
    15da:	08 95       	ret

000015dc <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    15dc:	80 91 32 01 	lds	r24, 0x0132
    15e0:	90 91 33 01 	lds	r25, 0x0133
    15e4:	89 2b       	or	r24, r25
    15e6:	39 f0       	breq	.+14     	; 0x15f6 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    15e8:	e0 91 32 01 	lds	r30, 0x0132
    15ec:	f0 91 33 01 	lds	r31, 0x0133
    15f0:	82 a1       	ldd	r24, Z+34	; 0x22
    15f2:	8f 5f       	subi	r24, 0xFF	; 255
    15f4:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    15f6:	20 91 32 01 	lds	r18, 0x0132
    15fa:	30 91 33 01 	lds	r19, 0x0133
	}
    15fe:	82 2f       	mov	r24, r18
    1600:	93 2f       	mov	r25, r19
    1602:	08 95       	ret

00001604 <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    1604:	0f b6       	in	r0, 0x3f	; 63
    1606:	f8 94       	cli
    1608:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    160a:	80 91 88 01 	lds	r24, 0x0188
    160e:	90 91 89 01 	lds	r25, 0x0189
    1612:	89 2b       	or	r24, r25
    1614:	e9 f4       	brne	.+58     	; 0x1650 <prvCheckForValidListAndQueue+0x4c>
		{
			vListInitialise( &xActiveTimerList1 );
    1616:	82 e9       	ldi	r24, 0x92	; 146
    1618:	91 e0       	ldi	r25, 0x01	; 1
    161a:	0e 94 ca 00 	call	0x194	; 0x194 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    161e:	8b e9       	ldi	r24, 0x9B	; 155
    1620:	91 e0       	ldi	r25, 0x01	; 1
    1622:	0e 94 ca 00 	call	0x194	; 0x194 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    1626:	82 e9       	ldi	r24, 0x92	; 146
    1628:	91 e0       	ldi	r25, 0x01	; 1
    162a:	90 93 8d 01 	sts	0x018D, r25
    162e:	80 93 8c 01 	sts	0x018C, r24
			pxOverflowTimerList = &xActiveTimerList2;
    1632:	8b e9       	ldi	r24, 0x9B	; 155
    1634:	91 e0       	ldi	r25, 0x01	; 1
    1636:	90 93 8f 01 	sts	0x018F, r25
    163a:	80 93 8e 01 	sts	0x018E, r24

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    163e:	40 e0       	ldi	r20, 0x00	; 0
    1640:	65 e0       	ldi	r22, 0x05	; 5
    1642:	8a e0       	ldi	r24, 0x0A	; 10
    1644:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <xQueueGenericCreate>
    1648:	90 93 89 01 	sts	0x0189, r25
    164c:	80 93 88 01 	sts	0x0188, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1650:	0f 90       	pop	r0
    1652:	0f be       	out	0x3f, r0	; 63
    1654:	08 95       	ret

00001656 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    1656:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    1658:	73 83       	std	Z+3, r23	; 0x03
    165a:	62 83       	std	Z+2, r22	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    165c:	91 87       	std	Z+9, r25	; 0x09
    165e:	80 87       	std	Z+8, r24	; 0x08

	if( xNextExpiryTime <= xTimeNow )
    1660:	46 17       	cp	r20, r22
    1662:	57 07       	cpc	r21, r23
    1664:	90 f0       	brcs	.+36     	; 0x168a <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1666:	42 1b       	sub	r20, r18
    1668:	53 0b       	sbc	r21, r19
    166a:	84 85       	ldd	r24, Z+12	; 0x0c
    166c:	95 85       	ldd	r25, Z+13	; 0x0d
    166e:	48 17       	cp	r20, r24
    1670:	59 07       	cpc	r21, r25
    1672:	e0 f4       	brcc	.+56     	; 0x16ac <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    1674:	bf 01       	movw	r22, r30
    1676:	6e 5f       	subi	r22, 0xFE	; 254
    1678:	7f 4f       	sbci	r23, 0xFF	; 255
    167a:	80 91 8e 01 	lds	r24, 0x018E
    167e:	90 91 8f 01 	lds	r25, 0x018F
    1682:	0e 94 fd 00 	call	0x1fa	; 0x1fa <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    1686:	80 e0       	ldi	r24, 0x00	; 0
    1688:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    168a:	42 17       	cp	r20, r18
    168c:	53 07       	cpc	r21, r19
    168e:	18 f4       	brcc	.+6      	; 0x1696 <prvInsertTimerInActiveList+0x40>
    1690:	62 17       	cp	r22, r18
    1692:	73 07       	cpc	r23, r19
    1694:	68 f4       	brcc	.+26     	; 0x16b0 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1696:	bf 01       	movw	r22, r30
    1698:	6e 5f       	subi	r22, 0xFE	; 254
    169a:	7f 4f       	sbci	r23, 0xFF	; 255
    169c:	80 91 8c 01 	lds	r24, 0x018C
    16a0:	90 91 8d 01 	lds	r25, 0x018D
    16a4:	0e 94 fd 00 	call	0x1fa	; 0x1fa <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    16a8:	80 e0       	ldi	r24, 0x00	; 0
    16aa:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    16ac:	81 e0       	ldi	r24, 0x01	; 1
    16ae:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    16b0:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    16b2:	08 95       	ret

000016b4 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    16b4:	ef 92       	push	r14
    16b6:	ff 92       	push	r15
    16b8:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    16ba:	0e 94 02 0b 	call	0x1604	; 0x1604 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    16be:	80 91 88 01 	lds	r24, 0x0188
    16c2:	90 91 89 01 	lds	r25, 0x0189
    16c6:	89 2b       	or	r24, r25
    16c8:	91 f0       	breq	.+36     	; 0x16ee <xTimerCreateTimerTask+0x3a>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
    16ca:	0f 2e       	mov	r0, r31
    16cc:	fa e8       	ldi	r31, 0x8A	; 138
    16ce:	ef 2e       	mov	r14, r31
    16d0:	f1 e0       	ldi	r31, 0x01	; 1
    16d2:	ff 2e       	mov	r15, r31
    16d4:	f0 2d       	mov	r31, r0
    16d6:	03 e0       	ldi	r16, 0x03	; 3
    16d8:	20 e0       	ldi	r18, 0x00	; 0
    16da:	30 e0       	ldi	r19, 0x00	; 0
    16dc:	45 e5       	ldi	r20, 0x55	; 85
    16de:	50 e0       	ldi	r21, 0x00	; 0
    16e0:	69 e1       	ldi	r22, 0x19	; 25
    16e2:	71 e0       	ldi	r23, 0x01	; 1
    16e4:	85 e3       	ldi	r24, 0x35	; 53
    16e6:	9c e0       	ldi	r25, 0x0C	; 12
    16e8:	0e 94 5a 06 	call	0xcb4	; 0xcb4 <xTaskCreate>
    16ec:	01 c0       	rjmp	.+2      	; 0x16f0 <xTimerCreateTimerTask+0x3c>
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    16ee:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    16f0:	0f 91       	pop	r16
    16f2:	ff 90       	pop	r15
    16f4:	ef 90       	pop	r14
    16f6:	08 95       	ret

000016f8 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    16f8:	0f 93       	push	r16
    16fa:	1f 93       	push	r17
    16fc:	cf 93       	push	r28
    16fe:	df 93       	push	r29
    1700:	00 d0       	rcall	.+0      	; 0x1702 <xTimerGenericCommand+0xa>
    1702:	00 d0       	rcall	.+0      	; 0x1704 <xTimerGenericCommand+0xc>
    1704:	1f 92       	push	r1
    1706:	cd b7       	in	r28, 0x3d	; 61
    1708:	de b7       	in	r29, 0x3e	; 62
    170a:	d9 01       	movw	r26, r18

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    170c:	e0 91 88 01 	lds	r30, 0x0188
    1710:	f0 91 89 01 	lds	r31, 0x0189
    1714:	30 97       	sbiw	r30, 0x00	; 0
    1716:	69 f1       	breq	.+90     	; 0x1772 <xTimerGenericCommand+0x7a>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    1718:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    171a:	5b 83       	std	Y+3, r21	; 0x03
    171c:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    171e:	9d 83       	std	Y+5, r25	; 0x05
    1720:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1722:	66 30       	cpi	r22, 0x06	; 6
    1724:	ec f4       	brge	.+58     	; 0x1760 <xTimerGenericCommand+0x68>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1726:	0e 94 43 0a 	call	0x1486	; 0x1486 <xTaskGetSchedulerState>
    172a:	82 30       	cpi	r24, 0x02	; 2
    172c:	61 f4       	brne	.+24     	; 0x1746 <xTimerGenericCommand+0x4e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    172e:	20 e0       	ldi	r18, 0x00	; 0
    1730:	a8 01       	movw	r20, r16
    1732:	be 01       	movw	r22, r28
    1734:	6f 5f       	subi	r22, 0xFF	; 255
    1736:	7f 4f       	sbci	r23, 0xFF	; 255
    1738:	80 91 88 01 	lds	r24, 0x0188
    173c:	90 91 89 01 	lds	r25, 0x0189
    1740:	0e 94 1b 04 	call	0x836	; 0x836 <xQueueGenericSend>
    1744:	17 c0       	rjmp	.+46     	; 0x1774 <xTimerGenericCommand+0x7c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1746:	20 e0       	ldi	r18, 0x00	; 0
    1748:	40 e0       	ldi	r20, 0x00	; 0
    174a:	50 e0       	ldi	r21, 0x00	; 0
    174c:	be 01       	movw	r22, r28
    174e:	6f 5f       	subi	r22, 0xFF	; 255
    1750:	7f 4f       	sbci	r23, 0xFF	; 255
    1752:	80 91 88 01 	lds	r24, 0x0188
    1756:	90 91 89 01 	lds	r25, 0x0189
    175a:	0e 94 1b 04 	call	0x836	; 0x836 <xQueueGenericSend>
    175e:	0a c0       	rjmp	.+20     	; 0x1774 <xTimerGenericCommand+0x7c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1760:	20 e0       	ldi	r18, 0x00	; 0
    1762:	ad 01       	movw	r20, r26
    1764:	be 01       	movw	r22, r28
    1766:	6f 5f       	subi	r22, 0xFF	; 255
    1768:	7f 4f       	sbci	r23, 0xFF	; 255
    176a:	cf 01       	movw	r24, r30
    176c:	0e 94 bc 04 	call	0x978	; 0x978 <xQueueGenericSendFromISR>
    1770:	01 c0       	rjmp	.+2      	; 0x1774 <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    1772:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    1774:	0f 90       	pop	r0
    1776:	0f 90       	pop	r0
    1778:	0f 90       	pop	r0
    177a:	0f 90       	pop	r0
    177c:	0f 90       	pop	r0
    177e:	df 91       	pop	r29
    1780:	cf 91       	pop	r28
    1782:	1f 91       	pop	r17
    1784:	0f 91       	pop	r16
    1786:	08 95       	ret

00001788 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    1788:	af 92       	push	r10
    178a:	bf 92       	push	r11
    178c:	cf 92       	push	r12
    178e:	df 92       	push	r13
    1790:	ef 92       	push	r14
    1792:	ff 92       	push	r15
    1794:	0f 93       	push	r16
    1796:	1f 93       	push	r17
    1798:	cf 93       	push	r28
    179a:	df 93       	push	r29
    179c:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    179e:	0e 94 ae 07 	call	0xf5c	; 0xf5c <xTaskGetTickCount>
    17a2:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    17a4:	80 91 90 01 	lds	r24, 0x0190
    17a8:	90 91 91 01 	lds	r25, 0x0191
    17ac:	e8 16       	cp	r14, r24
    17ae:	f9 06       	cpc	r15, r25
    17b0:	08 f0       	brcs	.+2      	; 0x17b4 <prvSampleTimeNow+0x2c>
    17b2:	48 c0       	rjmp	.+144    	; 0x1844 <prvSampleTimeNow+0xbc>
    17b4:	30 c0       	rjmp	.+96     	; 0x1816 <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    17b6:	05 80       	ldd	r0, Z+5	; 0x05
    17b8:	f6 81       	ldd	r31, Z+6	; 0x06
    17ba:	e0 2d       	mov	r30, r0
    17bc:	a0 80       	ld	r10, Z
    17be:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    17c0:	c6 81       	ldd	r28, Z+6	; 0x06
    17c2:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    17c4:	8e 01       	movw	r16, r28
    17c6:	0e 5f       	subi	r16, 0xFE	; 254
    17c8:	1f 4f       	sbci	r17, 0xFF	; 255
    17ca:	c8 01       	movw	r24, r16
    17cc:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    17d0:	e9 89       	ldd	r30, Y+17	; 0x11
    17d2:	fa 89       	ldd	r31, Y+18	; 0x12
    17d4:	ce 01       	movw	r24, r28
    17d6:	09 95       	icall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    17d8:	8e 85       	ldd	r24, Y+14	; 0x0e
    17da:	81 30       	cpi	r24, 0x01	; 1
    17dc:	e1 f4       	brne	.+56     	; 0x1816 <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    17de:	8c 85       	ldd	r24, Y+12	; 0x0c
    17e0:	9d 85       	ldd	r25, Y+13	; 0x0d
    17e2:	8a 0d       	add	r24, r10
    17e4:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    17e6:	a8 16       	cp	r10, r24
    17e8:	b9 06       	cpc	r11, r25
    17ea:	60 f4       	brcc	.+24     	; 0x1804 <prvSampleTimeNow+0x7c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    17ec:	9b 83       	std	Y+3, r25	; 0x03
    17ee:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    17f0:	d9 87       	std	Y+9, r29	; 0x09
    17f2:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    17f4:	b8 01       	movw	r22, r16
    17f6:	80 91 8c 01 	lds	r24, 0x018C
    17fa:	90 91 8d 01 	lds	r25, 0x018D
    17fe:	0e 94 fd 00 	call	0x1fa	; 0x1fa <vListInsert>
    1802:	09 c0       	rjmp	.+18     	; 0x1816 <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1804:	00 e0       	ldi	r16, 0x00	; 0
    1806:	10 e0       	ldi	r17, 0x00	; 0
    1808:	20 e0       	ldi	r18, 0x00	; 0
    180a:	30 e0       	ldi	r19, 0x00	; 0
    180c:	a5 01       	movw	r20, r10
    180e:	60 e0       	ldi	r22, 0x00	; 0
    1810:	ce 01       	movw	r24, r28
    1812:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1816:	e0 91 8c 01 	lds	r30, 0x018C
    181a:	f0 91 8d 01 	lds	r31, 0x018D
    181e:	80 81       	ld	r24, Z
    1820:	81 11       	cpse	r24, r1
    1822:	c9 cf       	rjmp	.-110    	; 0x17b6 <prvSampleTimeNow+0x2e>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    1824:	80 91 8e 01 	lds	r24, 0x018E
    1828:	90 91 8f 01 	lds	r25, 0x018F
    182c:	90 93 8d 01 	sts	0x018D, r25
    1830:	80 93 8c 01 	sts	0x018C, r24
	pxOverflowTimerList = pxTemp;
    1834:	f0 93 8f 01 	sts	0x018F, r31
    1838:	e0 93 8e 01 	sts	0x018E, r30
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    183c:	81 e0       	ldi	r24, 0x01	; 1
    183e:	f6 01       	movw	r30, r12
    1840:	80 83       	st	Z, r24
    1842:	02 c0       	rjmp	.+4      	; 0x1848 <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    1844:	f6 01       	movw	r30, r12
    1846:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    1848:	f0 92 91 01 	sts	0x0191, r15
    184c:	e0 92 90 01 	sts	0x0190, r14

	return xTimeNow;
}
    1850:	8e 2d       	mov	r24, r14
    1852:	9f 2d       	mov	r25, r15
    1854:	df 91       	pop	r29
    1856:	cf 91       	pop	r28
    1858:	1f 91       	pop	r17
    185a:	0f 91       	pop	r16
    185c:	ff 90       	pop	r15
    185e:	ef 90       	pop	r14
    1860:	df 90       	pop	r13
    1862:	cf 90       	pop	r12
    1864:	bf 90       	pop	r11
    1866:	af 90       	pop	r10
    1868:	08 95       	ret

0000186a <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    186a:	cf 93       	push	r28
    186c:	df 93       	push	r29
    186e:	00 d0       	rcall	.+0      	; 0x1870 <prvTimerTask+0x6>
    1870:	00 d0       	rcall	.+0      	; 0x1872 <prvTimerTask+0x8>
    1872:	00 d0       	rcall	.+0      	; 0x1874 <prvTimerTask+0xa>
    1874:	cd b7       	in	r28, 0x3d	; 61
    1876:	de b7       	in	r29, 0x3e	; 62
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1878:	aa 24       	eor	r10, r10
    187a:	a3 94       	inc	r10
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    187c:	e1 2c       	mov	r14, r1
    187e:	f1 2c       	mov	r15, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1880:	b1 2c       	mov	r11, r1
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1882:	e0 91 8c 01 	lds	r30, 0x018C
    1886:	f0 91 8d 01 	lds	r31, 0x018D
	if( *pxListWasEmpty == pdFALSE )
    188a:	80 81       	ld	r24, Z
    188c:	88 23       	and	r24, r24
    188e:	09 f4       	brne	.+2      	; 0x1892 <prvTimerTask+0x28>
    1890:	ce c0       	rjmp	.+412    	; 0x1a2e <prvTimerTask+0x1c4>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1892:	05 80       	ldd	r0, Z+5	; 0x05
    1894:	f6 81       	ldd	r31, Z+6	; 0x06
    1896:	e0 2d       	mov	r30, r0
    1898:	c0 80       	ld	r12, Z
    189a:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    189c:	0e 94 a8 07 	call	0xf50	; 0xf50 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    18a0:	ce 01       	movw	r24, r28
    18a2:	06 96       	adiw	r24, 0x06	; 6
    18a4:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvSampleTimeNow>
    18a8:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    18aa:	8e 81       	ldd	r24, Y+6	; 0x06
    18ac:	81 11       	cpse	r24, r1
    18ae:	4f c0       	rjmp	.+158    	; 0x194e <prvTimerTask+0xe4>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    18b0:	0c 15       	cp	r16, r12
    18b2:	1d 05       	cpc	r17, r13
    18b4:	d8 f1       	brcs	.+118    	; 0x192c <prvTimerTask+0xc2>
			{
				( void ) xTaskResumeAll();
    18b6:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    18ba:	e0 91 8c 01 	lds	r30, 0x018C
    18be:	f0 91 8d 01 	lds	r31, 0x018D
    18c2:	05 80       	ldd	r0, Z+5	; 0x05
    18c4:	f6 81       	ldd	r31, Z+6	; 0x06
    18c6:	e0 2d       	mov	r30, r0
    18c8:	86 80       	ldd	r8, Z+6	; 0x06
    18ca:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    18cc:	c4 01       	movw	r24, r8
    18ce:	02 96       	adiw	r24, 0x02	; 2
    18d0:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    18d4:	d4 01       	movw	r26, r8
    18d6:	1e 96       	adiw	r26, 0x0e	; 14
    18d8:	8c 91       	ld	r24, X
    18da:	1e 97       	sbiw	r26, 0x0e	; 14
    18dc:	81 30       	cpi	r24, 0x01	; 1
    18de:	a1 f4       	brne	.+40     	; 0x1908 <prvTimerTask+0x9e>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    18e0:	1c 96       	adiw	r26, 0x0c	; 12
    18e2:	6d 91       	ld	r22, X+
    18e4:	7c 91       	ld	r23, X
    18e6:	1d 97       	sbiw	r26, 0x0d	; 13
    18e8:	6c 0d       	add	r22, r12
    18ea:	7d 1d       	adc	r23, r13
    18ec:	96 01       	movw	r18, r12
    18ee:	a8 01       	movw	r20, r16
    18f0:	c4 01       	movw	r24, r8
    18f2:	0e 94 2b 0b 	call	0x1656	; 0x1656 <prvInsertTimerInActiveList>
    18f6:	88 23       	and	r24, r24
    18f8:	39 f0       	breq	.+14     	; 0x1908 <prvTimerTask+0x9e>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    18fa:	87 01       	movw	r16, r14
    18fc:	97 01       	movw	r18, r14
    18fe:	a6 01       	movw	r20, r12
    1900:	6b 2d       	mov	r22, r11
    1902:	c4 01       	movw	r24, r8
    1904:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1908:	d4 01       	movw	r26, r8
    190a:	51 96       	adiw	r26, 0x11	; 17
    190c:	ed 91       	ld	r30, X+
    190e:	fc 91       	ld	r31, X
    1910:	52 97       	sbiw	r26, 0x12	; 18
    1912:	c4 01       	movw	r24, r8
    1914:	09 95       	icall
    1916:	7d c0       	rjmp	.+250    	; 0x1a12 <prvTimerTask+0x1a8>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1918:	e0 91 8e 01 	lds	r30, 0x018E
    191c:	f0 91 8f 01 	lds	r31, 0x018F
    1920:	4a 2d       	mov	r20, r10
    1922:	80 81       	ld	r24, Z
    1924:	81 11       	cpse	r24, r1
    1926:	4b 2d       	mov	r20, r11
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    1928:	67 01       	movw	r12, r14
    192a:	01 c0       	rjmp	.+2      	; 0x192e <prvTimerTask+0xc4>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    192c:	4b 2d       	mov	r20, r11
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    192e:	b6 01       	movw	r22, r12
    1930:	60 1b       	sub	r22, r16
    1932:	71 0b       	sbc	r23, r17
    1934:	80 91 88 01 	lds	r24, 0x0188
    1938:	90 91 89 01 	lds	r25, 0x0189
    193c:	0e 94 b9 05 	call	0xb72	; 0xb72 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    1940:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>
    1944:	81 11       	cpse	r24, r1
    1946:	65 c0       	rjmp	.+202    	; 0x1a12 <prvTimerTask+0x1a8>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    1948:	0e 94 21 02 	call	0x442	; 0x442 <vPortYield>
    194c:	62 c0       	rjmp	.+196    	; 0x1a12 <prvTimerTask+0x1a8>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    194e:	0e 94 77 08 	call	0x10ee	; 0x10ee <xTaskResumeAll>
    1952:	5f c0       	rjmp	.+190    	; 0x1a12 <prvTimerTask+0x1a8>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1954:	89 81       	ldd	r24, Y+1	; 0x01
    1956:	88 23       	and	r24, r24
    1958:	0c f4       	brge	.+2      	; 0x195c <prvTimerTask+0xf2>
    195a:	5b c0       	rjmp	.+182    	; 0x1a12 <prvTimerTask+0x1a8>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    195c:	cc 80       	ldd	r12, Y+4	; 0x04
    195e:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    1960:	f6 01       	movw	r30, r12
    1962:	82 85       	ldd	r24, Z+10	; 0x0a
    1964:	93 85       	ldd	r25, Z+11	; 0x0b
    1966:	89 2b       	or	r24, r25
    1968:	21 f0       	breq	.+8      	; 0x1972 <prvTimerTask+0x108>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    196a:	c6 01       	movw	r24, r12
    196c:	02 96       	adiw	r24, 0x02	; 2
    196e:	0e 94 2e 01 	call	0x25c	; 0x25c <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1972:	ce 01       	movw	r24, r28
    1974:	06 96       	adiw	r24, 0x06	; 6
    1976:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    197a:	29 81       	ldd	r18, Y+1	; 0x01
    197c:	25 30       	cpi	r18, 0x05	; 5
    197e:	09 f4       	brne	.+2      	; 0x1982 <prvTimerTask+0x118>
    1980:	45 c0       	rjmp	.+138    	; 0x1a0c <prvTimerTask+0x1a2>
    1982:	4c f4       	brge	.+18     	; 0x1996 <prvTimerTask+0x12c>
    1984:	22 23       	and	r18, r18
    1986:	0c f4       	brge	.+2      	; 0x198a <prvTimerTask+0x120>
    1988:	44 c0       	rjmp	.+136    	; 0x1a12 <prvTimerTask+0x1a8>
    198a:	23 30       	cpi	r18, 0x03	; 3
    198c:	4c f0       	brlt	.+18     	; 0x19a0 <prvTimerTask+0x136>
    198e:	24 30       	cpi	r18, 0x04	; 4
    1990:	09 f0       	breq	.+2      	; 0x1994 <prvTimerTask+0x12a>
    1992:	3f c0       	rjmp	.+126    	; 0x1a12 <prvTimerTask+0x1a8>
    1994:	2c c0       	rjmp	.+88     	; 0x19ee <prvTimerTask+0x184>
    1996:	28 30       	cpi	r18, 0x08	; 8
    1998:	1c f0       	brlt	.+6      	; 0x19a0 <prvTimerTask+0x136>
    199a:	29 30       	cpi	r18, 0x09	; 9
    199c:	d1 f5       	brne	.+116    	; 0x1a12 <prvTimerTask+0x1a8>
    199e:	27 c0       	rjmp	.+78     	; 0x19ee <prvTimerTask+0x184>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    19a0:	2a 81       	ldd	r18, Y+2	; 0x02
    19a2:	3b 81       	ldd	r19, Y+3	; 0x03
    19a4:	d6 01       	movw	r26, r12
    19a6:	1c 96       	adiw	r26, 0x0c	; 12
    19a8:	6d 91       	ld	r22, X+
    19aa:	7c 91       	ld	r23, X
    19ac:	1d 97       	sbiw	r26, 0x0d	; 13
    19ae:	62 0f       	add	r22, r18
    19b0:	73 1f       	adc	r23, r19
    19b2:	ac 01       	movw	r20, r24
    19b4:	c6 01       	movw	r24, r12
    19b6:	0e 94 2b 0b 	call	0x1656	; 0x1656 <prvInsertTimerInActiveList>
    19ba:	88 23       	and	r24, r24
    19bc:	51 f1       	breq	.+84     	; 0x1a12 <prvTimerTask+0x1a8>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    19be:	d6 01       	movw	r26, r12
    19c0:	51 96       	adiw	r26, 0x11	; 17
    19c2:	ed 91       	ld	r30, X+
    19c4:	fc 91       	ld	r31, X
    19c6:	52 97       	sbiw	r26, 0x12	; 18
    19c8:	c6 01       	movw	r24, r12
    19ca:	09 95       	icall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    19cc:	f6 01       	movw	r30, r12
    19ce:	86 85       	ldd	r24, Z+14	; 0x0e
    19d0:	81 30       	cpi	r24, 0x01	; 1
    19d2:	f9 f4       	brne	.+62     	; 0x1a12 <prvTimerTask+0x1a8>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    19d4:	44 85       	ldd	r20, Z+12	; 0x0c
    19d6:	55 85       	ldd	r21, Z+13	; 0x0d
    19d8:	8a 81       	ldd	r24, Y+2	; 0x02
    19da:	9b 81       	ldd	r25, Y+3	; 0x03
    19dc:	48 0f       	add	r20, r24
    19de:	59 1f       	adc	r21, r25
    19e0:	87 01       	movw	r16, r14
    19e2:	97 01       	movw	r18, r14
    19e4:	6b 2d       	mov	r22, r11
    19e6:	c6 01       	movw	r24, r12
    19e8:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <xTimerGenericCommand>
    19ec:	12 c0       	rjmp	.+36     	; 0x1a12 <prvTimerTask+0x1a8>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    19ee:	6a 81       	ldd	r22, Y+2	; 0x02
    19f0:	7b 81       	ldd	r23, Y+3	; 0x03
    19f2:	d6 01       	movw	r26, r12
    19f4:	1d 96       	adiw	r26, 0x0d	; 13
    19f6:	7c 93       	st	X, r23
    19f8:	6e 93       	st	-X, r22
    19fa:	1c 97       	sbiw	r26, 0x0c	; 12
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    19fc:	68 0f       	add	r22, r24
    19fe:	79 1f       	adc	r23, r25
    1a00:	9c 01       	movw	r18, r24
    1a02:	ac 01       	movw	r20, r24
    1a04:	c6 01       	movw	r24, r12
    1a06:	0e 94 2b 0b 	call	0x1656	; 0x1656 <prvInsertTimerInActiveList>
    1a0a:	03 c0       	rjmp	.+6      	; 0x1a12 <prvTimerTask+0x1a8>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    1a0c:	c6 01       	movw	r24, r12
    1a0e:	0e 94 bb 00 	call	0x176	; 0x176 <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1a12:	2b 2d       	mov	r18, r11
    1a14:	a7 01       	movw	r20, r14
    1a16:	be 01       	movw	r22, r28
    1a18:	6f 5f       	subi	r22, 0xFF	; 255
    1a1a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a1c:	80 91 88 01 	lds	r24, 0x0188
    1a20:	90 91 89 01 	lds	r25, 0x0189
    1a24:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <xQueueGenericReceive>
    1a28:	81 11       	cpse	r24, r1
    1a2a:	94 cf       	rjmp	.-216    	; 0x1954 <prvTimerTask+0xea>
    1a2c:	2a cf       	rjmp	.-428    	; 0x1882 <prvTimerTask+0x18>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    1a2e:	0e 94 a8 07 	call	0xf50	; 0xf50 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1a32:	ce 01       	movw	r24, r28
    1a34:	06 96       	adiw	r24, 0x06	; 6
    1a36:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvSampleTimeNow>
    1a3a:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    1a3c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a3e:	88 23       	and	r24, r24
    1a40:	09 f4       	brne	.+2      	; 0x1a44 <prvTimerTask+0x1da>
    1a42:	6a cf       	rjmp	.-300    	; 0x1918 <prvTimerTask+0xae>
    1a44:	84 cf       	rjmp	.-248    	; 0x194e <prvTimerTask+0xe4>

00001a46 <malloc>:
    1a46:	0f 93       	push	r16
    1a48:	1f 93       	push	r17
    1a4a:	cf 93       	push	r28
    1a4c:	df 93       	push	r29
    1a4e:	82 30       	cpi	r24, 0x02	; 2
    1a50:	91 05       	cpc	r25, r1
    1a52:	10 f4       	brcc	.+4      	; 0x1a58 <malloc+0x12>
    1a54:	82 e0       	ldi	r24, 0x02	; 2
    1a56:	90 e0       	ldi	r25, 0x00	; 0
    1a58:	e0 91 a6 01 	lds	r30, 0x01A6
    1a5c:	f0 91 a7 01 	lds	r31, 0x01A7
    1a60:	20 e0       	ldi	r18, 0x00	; 0
    1a62:	30 e0       	ldi	r19, 0x00	; 0
    1a64:	c0 e0       	ldi	r28, 0x00	; 0
    1a66:	d0 e0       	ldi	r29, 0x00	; 0
    1a68:	23 c0       	rjmp	.+70     	; 0x1ab0 <malloc+0x6a>
    1a6a:	40 81       	ld	r20, Z
    1a6c:	51 81       	ldd	r21, Z+1	; 0x01
    1a6e:	48 17       	cp	r20, r24
    1a70:	59 07       	cpc	r21, r25
    1a72:	a8 f0       	brcs	.+42     	; 0x1a9e <malloc+0x58>
    1a74:	48 17       	cp	r20, r24
    1a76:	59 07       	cpc	r21, r25
    1a78:	61 f4       	brne	.+24     	; 0x1a92 <malloc+0x4c>
    1a7a:	82 81       	ldd	r24, Z+2	; 0x02
    1a7c:	93 81       	ldd	r25, Z+3	; 0x03
    1a7e:	20 97       	sbiw	r28, 0x00	; 0
    1a80:	19 f0       	breq	.+6      	; 0x1a88 <malloc+0x42>
    1a82:	9b 83       	std	Y+3, r25	; 0x03
    1a84:	8a 83       	std	Y+2, r24	; 0x02
    1a86:	2e c0       	rjmp	.+92     	; 0x1ae4 <malloc+0x9e>
    1a88:	90 93 a7 01 	sts	0x01A7, r25
    1a8c:	80 93 a6 01 	sts	0x01A6, r24
    1a90:	29 c0       	rjmp	.+82     	; 0x1ae4 <malloc+0x9e>
    1a92:	21 15       	cp	r18, r1
    1a94:	31 05       	cpc	r19, r1
    1a96:	29 f0       	breq	.+10     	; 0x1aa2 <malloc+0x5c>
    1a98:	42 17       	cp	r20, r18
    1a9a:	53 07       	cpc	r21, r19
    1a9c:	10 f0       	brcs	.+4      	; 0x1aa2 <malloc+0x5c>
    1a9e:	a9 01       	movw	r20, r18
    1aa0:	02 c0       	rjmp	.+4      	; 0x1aa6 <malloc+0x60>
    1aa2:	be 01       	movw	r22, r28
    1aa4:	df 01       	movw	r26, r30
    1aa6:	02 81       	ldd	r16, Z+2	; 0x02
    1aa8:	13 81       	ldd	r17, Z+3	; 0x03
    1aaa:	ef 01       	movw	r28, r30
    1aac:	9a 01       	movw	r18, r20
    1aae:	f8 01       	movw	r30, r16
    1ab0:	30 97       	sbiw	r30, 0x00	; 0
    1ab2:	d9 f6       	brne	.-74     	; 0x1a6a <malloc+0x24>
    1ab4:	21 15       	cp	r18, r1
    1ab6:	31 05       	cpc	r19, r1
    1ab8:	09 f1       	breq	.+66     	; 0x1afc <malloc+0xb6>
    1aba:	28 1b       	sub	r18, r24
    1abc:	39 0b       	sbc	r19, r25
    1abe:	24 30       	cpi	r18, 0x04	; 4
    1ac0:	31 05       	cpc	r19, r1
    1ac2:	90 f4       	brcc	.+36     	; 0x1ae8 <malloc+0xa2>
    1ac4:	12 96       	adiw	r26, 0x02	; 2
    1ac6:	8d 91       	ld	r24, X+
    1ac8:	9c 91       	ld	r25, X
    1aca:	13 97       	sbiw	r26, 0x03	; 3
    1acc:	61 15       	cp	r22, r1
    1ace:	71 05       	cpc	r23, r1
    1ad0:	21 f0       	breq	.+8      	; 0x1ada <malloc+0x94>
    1ad2:	fb 01       	movw	r30, r22
    1ad4:	93 83       	std	Z+3, r25	; 0x03
    1ad6:	82 83       	std	Z+2, r24	; 0x02
    1ad8:	04 c0       	rjmp	.+8      	; 0x1ae2 <malloc+0x9c>
    1ada:	90 93 a7 01 	sts	0x01A7, r25
    1ade:	80 93 a6 01 	sts	0x01A6, r24
    1ae2:	fd 01       	movw	r30, r26
    1ae4:	32 96       	adiw	r30, 0x02	; 2
    1ae6:	44 c0       	rjmp	.+136    	; 0x1b70 <malloc+0x12a>
    1ae8:	fd 01       	movw	r30, r26
    1aea:	e2 0f       	add	r30, r18
    1aec:	f3 1f       	adc	r31, r19
    1aee:	81 93       	st	Z+, r24
    1af0:	91 93       	st	Z+, r25
    1af2:	22 50       	subi	r18, 0x02	; 2
    1af4:	31 09       	sbc	r19, r1
    1af6:	2d 93       	st	X+, r18
    1af8:	3c 93       	st	X, r19
    1afa:	3a c0       	rjmp	.+116    	; 0x1b70 <malloc+0x12a>
    1afc:	20 91 a4 01 	lds	r18, 0x01A4
    1b00:	30 91 a5 01 	lds	r19, 0x01A5
    1b04:	23 2b       	or	r18, r19
    1b06:	41 f4       	brne	.+16     	; 0x1b18 <malloc+0xd2>
    1b08:	20 91 02 01 	lds	r18, 0x0102
    1b0c:	30 91 03 01 	lds	r19, 0x0103
    1b10:	30 93 a5 01 	sts	0x01A5, r19
    1b14:	20 93 a4 01 	sts	0x01A4, r18
    1b18:	20 91 00 01 	lds	r18, 0x0100
    1b1c:	30 91 01 01 	lds	r19, 0x0101
    1b20:	21 15       	cp	r18, r1
    1b22:	31 05       	cpc	r19, r1
    1b24:	41 f4       	brne	.+16     	; 0x1b36 <malloc+0xf0>
    1b26:	2d b7       	in	r18, 0x3d	; 61
    1b28:	3e b7       	in	r19, 0x3e	; 62
    1b2a:	40 91 04 01 	lds	r20, 0x0104
    1b2e:	50 91 05 01 	lds	r21, 0x0105
    1b32:	24 1b       	sub	r18, r20
    1b34:	35 0b       	sbc	r19, r21
    1b36:	e0 91 a4 01 	lds	r30, 0x01A4
    1b3a:	f0 91 a5 01 	lds	r31, 0x01A5
    1b3e:	e2 17       	cp	r30, r18
    1b40:	f3 07       	cpc	r31, r19
    1b42:	a0 f4       	brcc	.+40     	; 0x1b6c <malloc+0x126>
    1b44:	2e 1b       	sub	r18, r30
    1b46:	3f 0b       	sbc	r19, r31
    1b48:	28 17       	cp	r18, r24
    1b4a:	39 07       	cpc	r19, r25
    1b4c:	78 f0       	brcs	.+30     	; 0x1b6c <malloc+0x126>
    1b4e:	ac 01       	movw	r20, r24
    1b50:	4e 5f       	subi	r20, 0xFE	; 254
    1b52:	5f 4f       	sbci	r21, 0xFF	; 255
    1b54:	24 17       	cp	r18, r20
    1b56:	35 07       	cpc	r19, r21
    1b58:	48 f0       	brcs	.+18     	; 0x1b6c <malloc+0x126>
    1b5a:	4e 0f       	add	r20, r30
    1b5c:	5f 1f       	adc	r21, r31
    1b5e:	50 93 a5 01 	sts	0x01A5, r21
    1b62:	40 93 a4 01 	sts	0x01A4, r20
    1b66:	81 93       	st	Z+, r24
    1b68:	91 93       	st	Z+, r25
    1b6a:	02 c0       	rjmp	.+4      	; 0x1b70 <malloc+0x12a>
    1b6c:	e0 e0       	ldi	r30, 0x00	; 0
    1b6e:	f0 e0       	ldi	r31, 0x00	; 0
    1b70:	cf 01       	movw	r24, r30
    1b72:	df 91       	pop	r29
    1b74:	cf 91       	pop	r28
    1b76:	1f 91       	pop	r17
    1b78:	0f 91       	pop	r16
    1b7a:	08 95       	ret

00001b7c <free>:
    1b7c:	ef 92       	push	r14
    1b7e:	ff 92       	push	r15
    1b80:	0f 93       	push	r16
    1b82:	1f 93       	push	r17
    1b84:	cf 93       	push	r28
    1b86:	df 93       	push	r29
    1b88:	00 97       	sbiw	r24, 0x00	; 0
    1b8a:	09 f4       	brne	.+2      	; 0x1b8e <free+0x12>
    1b8c:	8f c0       	rjmp	.+286    	; 0x1cac <free+0x130>
    1b8e:	dc 01       	movw	r26, r24
    1b90:	12 97       	sbiw	r26, 0x02	; 2
    1b92:	13 96       	adiw	r26, 0x03	; 3
    1b94:	1c 92       	st	X, r1
    1b96:	1e 92       	st	-X, r1
    1b98:	12 97       	sbiw	r26, 0x02	; 2
    1b9a:	e0 90 a6 01 	lds	r14, 0x01A6
    1b9e:	f0 90 a7 01 	lds	r15, 0x01A7
    1ba2:	e1 14       	cp	r14, r1
    1ba4:	f1 04       	cpc	r15, r1
    1ba6:	89 f4       	brne	.+34     	; 0x1bca <free+0x4e>
    1ba8:	2d 91       	ld	r18, X+
    1baa:	3c 91       	ld	r19, X
    1bac:	11 97       	sbiw	r26, 0x01	; 1
    1bae:	28 0f       	add	r18, r24
    1bb0:	39 1f       	adc	r19, r25
    1bb2:	80 91 a4 01 	lds	r24, 0x01A4
    1bb6:	90 91 a5 01 	lds	r25, 0x01A5
    1bba:	82 17       	cp	r24, r18
    1bbc:	93 07       	cpc	r25, r19
    1bbe:	89 f5       	brne	.+98     	; 0x1c22 <free+0xa6>
    1bc0:	b0 93 a5 01 	sts	0x01A5, r27
    1bc4:	a0 93 a4 01 	sts	0x01A4, r26
    1bc8:	71 c0       	rjmp	.+226    	; 0x1cac <free+0x130>
    1bca:	e7 01       	movw	r28, r14
    1bcc:	20 e0       	ldi	r18, 0x00	; 0
    1bce:	30 e0       	ldi	r19, 0x00	; 0
    1bd0:	01 c0       	rjmp	.+2      	; 0x1bd4 <free+0x58>
    1bd2:	ea 01       	movw	r28, r20
    1bd4:	ca 17       	cp	r28, r26
    1bd6:	db 07       	cpc	r29, r27
    1bd8:	38 f4       	brcc	.+14     	; 0x1be8 <free+0x6c>
    1bda:	4a 81       	ldd	r20, Y+2	; 0x02
    1bdc:	5b 81       	ldd	r21, Y+3	; 0x03
    1bde:	9e 01       	movw	r18, r28
    1be0:	41 15       	cp	r20, r1
    1be2:	51 05       	cpc	r21, r1
    1be4:	b1 f7       	brne	.-20     	; 0x1bd2 <free+0x56>
    1be6:	22 c0       	rjmp	.+68     	; 0x1c2c <free+0xb0>
    1be8:	bc 01       	movw	r22, r24
    1bea:	62 50       	subi	r22, 0x02	; 2
    1bec:	71 09       	sbc	r23, r1
    1bee:	fb 01       	movw	r30, r22
    1bf0:	d3 83       	std	Z+3, r29	; 0x03
    1bf2:	c2 83       	std	Z+2, r28	; 0x02
    1bf4:	00 81       	ld	r16, Z
    1bf6:	11 81       	ldd	r17, Z+1	; 0x01
    1bf8:	ac 01       	movw	r20, r24
    1bfa:	40 0f       	add	r20, r16
    1bfc:	51 1f       	adc	r21, r17
    1bfe:	4c 17       	cp	r20, r28
    1c00:	5d 07       	cpc	r21, r29
    1c02:	61 f4       	brne	.+24     	; 0x1c1c <free+0xa0>
    1c04:	48 81       	ld	r20, Y
    1c06:	59 81       	ldd	r21, Y+1	; 0x01
    1c08:	40 0f       	add	r20, r16
    1c0a:	51 1f       	adc	r21, r17
    1c0c:	4e 5f       	subi	r20, 0xFE	; 254
    1c0e:	5f 4f       	sbci	r21, 0xFF	; 255
    1c10:	51 83       	std	Z+1, r21	; 0x01
    1c12:	40 83       	st	Z, r20
    1c14:	4a 81       	ldd	r20, Y+2	; 0x02
    1c16:	5b 81       	ldd	r21, Y+3	; 0x03
    1c18:	53 83       	std	Z+3, r21	; 0x03
    1c1a:	42 83       	std	Z+2, r20	; 0x02
    1c1c:	21 15       	cp	r18, r1
    1c1e:	31 05       	cpc	r19, r1
    1c20:	29 f4       	brne	.+10     	; 0x1c2c <free+0xb0>
    1c22:	b0 93 a7 01 	sts	0x01A7, r27
    1c26:	a0 93 a6 01 	sts	0x01A6, r26
    1c2a:	40 c0       	rjmp	.+128    	; 0x1cac <free+0x130>
    1c2c:	f9 01       	movw	r30, r18
    1c2e:	b3 83       	std	Z+3, r27	; 0x03
    1c30:	a2 83       	std	Z+2, r26	; 0x02
    1c32:	e9 01       	movw	r28, r18
    1c34:	69 91       	ld	r22, Y+
    1c36:	79 91       	ld	r23, Y+
    1c38:	c6 0f       	add	r28, r22
    1c3a:	d7 1f       	adc	r29, r23
    1c3c:	ac 17       	cp	r26, r28
    1c3e:	bd 07       	cpc	r27, r29
    1c40:	79 f4       	brne	.+30     	; 0x1c60 <free+0xe4>
    1c42:	dc 01       	movw	r26, r24
    1c44:	5e 91       	ld	r21, -X
    1c46:	4e 91       	ld	r20, -X
    1c48:	46 0f       	add	r20, r22
    1c4a:	57 1f       	adc	r21, r23
    1c4c:	4e 5f       	subi	r20, 0xFE	; 254
    1c4e:	5f 4f       	sbci	r21, 0xFF	; 255
    1c50:	51 83       	std	Z+1, r21	; 0x01
    1c52:	40 83       	st	Z, r20
    1c54:	12 96       	adiw	r26, 0x02	; 2
    1c56:	8d 91       	ld	r24, X+
    1c58:	9c 91       	ld	r25, X
    1c5a:	13 97       	sbiw	r26, 0x03	; 3
    1c5c:	93 83       	std	Z+3, r25	; 0x03
    1c5e:	82 83       	std	Z+2, r24	; 0x02
    1c60:	a0 e0       	ldi	r26, 0x00	; 0
    1c62:	b0 e0       	ldi	r27, 0x00	; 0
    1c64:	02 c0       	rjmp	.+4      	; 0x1c6a <free+0xee>
    1c66:	d7 01       	movw	r26, r14
    1c68:	7c 01       	movw	r14, r24
    1c6a:	f7 01       	movw	r30, r14
    1c6c:	82 81       	ldd	r24, Z+2	; 0x02
    1c6e:	93 81       	ldd	r25, Z+3	; 0x03
    1c70:	00 97       	sbiw	r24, 0x00	; 0
    1c72:	c9 f7       	brne	.-14     	; 0x1c66 <free+0xea>
    1c74:	c7 01       	movw	r24, r14
    1c76:	02 96       	adiw	r24, 0x02	; 2
    1c78:	20 81       	ld	r18, Z
    1c7a:	31 81       	ldd	r19, Z+1	; 0x01
    1c7c:	82 0f       	add	r24, r18
    1c7e:	93 1f       	adc	r25, r19
    1c80:	20 91 a4 01 	lds	r18, 0x01A4
    1c84:	30 91 a5 01 	lds	r19, 0x01A5
    1c88:	28 17       	cp	r18, r24
    1c8a:	39 07       	cpc	r19, r25
    1c8c:	79 f4       	brne	.+30     	; 0x1cac <free+0x130>
    1c8e:	10 97       	sbiw	r26, 0x00	; 0
    1c90:	29 f4       	brne	.+10     	; 0x1c9c <free+0x120>
    1c92:	10 92 a7 01 	sts	0x01A7, r1
    1c96:	10 92 a6 01 	sts	0x01A6, r1
    1c9a:	04 c0       	rjmp	.+8      	; 0x1ca4 <free+0x128>
    1c9c:	13 96       	adiw	r26, 0x03	; 3
    1c9e:	1c 92       	st	X, r1
    1ca0:	1e 92       	st	-X, r1
    1ca2:	12 97       	sbiw	r26, 0x02	; 2
    1ca4:	f0 92 a5 01 	sts	0x01A5, r15
    1ca8:	e0 92 a4 01 	sts	0x01A4, r14
    1cac:	cd b7       	in	r28, 0x3d	; 61
    1cae:	de b7       	in	r29, 0x3e	; 62
    1cb0:	e6 e0       	ldi	r30, 0x06	; 6
    1cb2:	0c 94 77 0e 	jmp	0x1cee	; 0x1cee <__epilogue_restores__+0x18>

00001cb6 <memcpy>:
    1cb6:	fb 01       	movw	r30, r22
    1cb8:	dc 01       	movw	r26, r24
    1cba:	02 c0       	rjmp	.+4      	; 0x1cc0 <memcpy+0xa>
    1cbc:	01 90       	ld	r0, Z+
    1cbe:	0d 92       	st	X+, r0
    1cc0:	41 50       	subi	r20, 0x01	; 1
    1cc2:	50 40       	sbci	r21, 0x00	; 0
    1cc4:	d8 f7       	brcc	.-10     	; 0x1cbc <memcpy+0x6>
    1cc6:	08 95       	ret

00001cc8 <memset>:
    1cc8:	dc 01       	movw	r26, r24
    1cca:	01 c0       	rjmp	.+2      	; 0x1cce <memset+0x6>
    1ccc:	6d 93       	st	X+, r22
    1cce:	41 50       	subi	r20, 0x01	; 1
    1cd0:	50 40       	sbci	r21, 0x00	; 0
    1cd2:	e0 f7       	brcc	.-8      	; 0x1ccc <memset+0x4>
    1cd4:	08 95       	ret

00001cd6 <__epilogue_restores__>:
    1cd6:	2a 88       	ldd	r2, Y+18	; 0x12
    1cd8:	39 88       	ldd	r3, Y+17	; 0x11
    1cda:	48 88       	ldd	r4, Y+16	; 0x10
    1cdc:	5f 84       	ldd	r5, Y+15	; 0x0f
    1cde:	6e 84       	ldd	r6, Y+14	; 0x0e
    1ce0:	7d 84       	ldd	r7, Y+13	; 0x0d
    1ce2:	8c 84       	ldd	r8, Y+12	; 0x0c
    1ce4:	9b 84       	ldd	r9, Y+11	; 0x0b
    1ce6:	aa 84       	ldd	r10, Y+10	; 0x0a
    1ce8:	b9 84       	ldd	r11, Y+9	; 0x09
    1cea:	c8 84       	ldd	r12, Y+8	; 0x08
    1cec:	df 80       	ldd	r13, Y+7	; 0x07
    1cee:	ee 80       	ldd	r14, Y+6	; 0x06
    1cf0:	fd 80       	ldd	r15, Y+5	; 0x05
    1cf2:	0c 81       	ldd	r16, Y+4	; 0x04
    1cf4:	1b 81       	ldd	r17, Y+3	; 0x03
    1cf6:	aa 81       	ldd	r26, Y+2	; 0x02
    1cf8:	b9 81       	ldd	r27, Y+1	; 0x01
    1cfa:	ce 0f       	add	r28, r30
    1cfc:	d1 1d       	adc	r29, r1
    1cfe:	0f b6       	in	r0, 0x3f	; 63
    1d00:	f8 94       	cli
    1d02:	de bf       	out	0x3e, r29	; 62
    1d04:	0f be       	out	0x3f, r0	; 63
    1d06:	cd bf       	out	0x3d, r28	; 61
    1d08:	ed 01       	movw	r28, r26
    1d0a:	08 95       	ret

00001d0c <_exit>:
    1d0c:	f8 94       	cli

00001d0e <__stop_program>:
    1d0e:	ff cf       	rjmp	.-2      	; 0x1d0e <__stop_program>
